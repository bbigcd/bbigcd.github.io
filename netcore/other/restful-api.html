<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>RESTful APIs 最佳实践 | bbigcd</title>
    <meta name="description" content="Make more time">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.0cbbf90a.css" as="style"><link rel="preload" href="/assets/js/app.fa3e3824.js" as="script"><link rel="preload" href="/assets/js/2.230529bd.js" as="script"><link rel="preload" href="/assets/js/23.0815466b.js" as="script"><link rel="prefetch" href="/assets/js/10.c93fe082.js"><link rel="prefetch" href="/assets/js/11.4bf3ae7f.js"><link rel="prefetch" href="/assets/js/12.01c45e0e.js"><link rel="prefetch" href="/assets/js/13.d9d858d9.js"><link rel="prefetch" href="/assets/js/14.00d956f4.js"><link rel="prefetch" href="/assets/js/15.679c6742.js"><link rel="prefetch" href="/assets/js/16.abbcd59e.js"><link rel="prefetch" href="/assets/js/17.1f5585d5.js"><link rel="prefetch" href="/assets/js/18.149d6c4f.js"><link rel="prefetch" href="/assets/js/19.4dd5acbe.js"><link rel="prefetch" href="/assets/js/20.874851b7.js"><link rel="prefetch" href="/assets/js/21.e8fab656.js"><link rel="prefetch" href="/assets/js/22.74ef4341.js"><link rel="prefetch" href="/assets/js/24.3923d245.js"><link rel="prefetch" href="/assets/js/25.dd992728.js"><link rel="prefetch" href="/assets/js/26.f9a0d7a7.js"><link rel="prefetch" href="/assets/js/27.54f139b7.js"><link rel="prefetch" href="/assets/js/28.070cfa63.js"><link rel="prefetch" href="/assets/js/29.eb08d370.js"><link rel="prefetch" href="/assets/js/3.447720c6.js"><link rel="prefetch" href="/assets/js/30.e66848e4.js"><link rel="prefetch" href="/assets/js/31.0438d4db.js"><link rel="prefetch" href="/assets/js/32.daf1012d.js"><link rel="prefetch" href="/assets/js/33.9f79b5b3.js"><link rel="prefetch" href="/assets/js/34.086724a3.js"><link rel="prefetch" href="/assets/js/35.90c07cc0.js"><link rel="prefetch" href="/assets/js/36.056ad52c.js"><link rel="prefetch" href="/assets/js/4.0f091beb.js"><link rel="prefetch" href="/assets/js/5.4c5d2735.js"><link rel="prefetch" href="/assets/js/6.a4af8558.js"><link rel="prefetch" href="/assets/js/7.8feeb04b.js"><link rel="prefetch" href="/assets/js/8.1af69973.js"><link rel="prefetch" href="/assets/js/9.e612d3ea.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0cbbf90a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">bbigcd</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/netcore/" class="nav-link router-link-active">NetCore</a></div><div class="nav-item"><a href="/csharp/" class="nav-link">CSharp</a></div><div class="nav-item"><a href="/post/" class="nav-link">Other</a></div><div class="nav-item"><a href="/about-me/" class="nav-link">AboutMe</a></div><div class="nav-item"><a href="https://www.github.com/bbigcd" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/netcore/" class="nav-link router-link-active">NetCore</a></div><div class="nav-item"><a href="/csharp/" class="nav-link">CSharp</a></div><div class="nav-item"><a href="/post/" class="nav-link">Other</a></div><div class="nav-item"><a href="/about-me/" class="nav-link">AboutMe</a></div><div class="nav-item"><a href="https://www.github.com/bbigcd" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/netcore/other/restful-api.html" class="active sidebar-link">RESTful APIs 最佳实践</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#先决条件" class="sidebar-link">先决条件</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#the-scope" class="sidebar-link">The Scope</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤1-创建-api" class="sidebar-link">步骤1 - 创建 API</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤2-创建领域模型" class="sidebar-link">步骤2 - 创建领域模型</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤3-类别-api" class="sidebar-link">步骤3 - 类别 API</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤4-类别服务实现" class="sidebar-link">步骤4 - 类别服务实现</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤5-类别仓储与持久层" class="sidebar-link">步骤5 - 类别仓储与持久层</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤6-配置依赖注入" class="sidebar-link">步骤6 - 配置依赖注入</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤7-测试分类的-api" class="sidebar-link">步骤7 - 测试分类的 API</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤8-创建一个分类资源" class="sidebar-link">步骤8 - 创建一个分类资源</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤9-创建新的分类" class="sidebar-link">步骤9 - 创建新的分类</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤10-使用模型状态验证请求主体" class="sidebar-link">步骤10 - 使用模型状态验证请求主体</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤11-映射新的资源" class="sidebar-link">步骤11 - 映射新的资源</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤12-使用请求-响应模式来处理保存逻辑" class="sidebar-link">步骤12 - 使用请求-响应模式来处理保存逻辑</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤13-数据库逻辑和工作模式单元" class="sidebar-link">步骤13 - 数据库逻辑和工作模式单元</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤14-使用postman测试我们的post端点" class="sidebar-link">步骤14 - 使用Postman测试我们的POST端点</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤15-更新类别" class="sidebar-link">步骤15 - 更新类别</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤16-更新逻辑" class="sidebar-link">步骤16 - 更新逻辑</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤17-删除类别" class="sidebar-link">步骤17 - 删除类别</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#步骤18-产品的api" class="sidebar-link">步骤18 - 产品的API</a></li><li class="sidebar-sub-header"><a href="/netcore/other/restful-api.html#结语" class="sidebar-link">结语</a></li></ul></li><li><a href="/netcore/other/netcore-tips.html" class="sidebar-link">DotNetCore 开发踩坑记录</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/netcore/other/netcore-tips.html#开发工具" class="sidebar-link">开发工具</a></li></ul></li><li><a href="/netcore/other/geojson.html" class="sidebar-link">地理空间处理与分析</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="「翻译」手摸手教你如何实现干净的、易维护的-restful-apis"><a href="#「翻译」手摸手教你如何实现干净的、易维护的-restful-apis" class="header-anchor">#</a> 「翻译」手摸手教你如何实现干净的、易维护的 RESTful APIs</h3> <p>原文链接 <a href="https://www.freecodecamp.org/news/an-awesome-guide-on-how-to-build-restful-apis-with-asp-net-core-87b818123e28/" target="_blank" rel="noopener noreferrer">An awesome guide on how to build RESTful APIs with ASP.NET Core<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>约定: 文中的 API Endpoint 中的<strong>Endpoint</strong>翻译为端点, 其意思为WEB API接口的资源终点位置</p> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <p><code>RESTful</code> 不是一个新的术语。它指的是web服务从客户端应用程序接收和发送数据的架构风格。这些应用程序的目标是集中不同客户端应用程序将使用的数据。</p> <p>选择一个恰当的工具来编写 <code>RESTful</code> 服务是非常重要的, 因为我们需要考虑到可伸缩性、可维护性、文档是否健全以及其他相关方面。<a href="https://docs.microsoft.com/en-us/aspnet/" target="_blank" rel="noopener noreferrer">ASP.NET Core<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 为我们提供了一个功能强大、易于使用的 API 来实现这一个目标。</p> <p>在本篇文章中, 我会使用 ASP.NET Core 框架, 来向你展示一个“几乎”真实的场景编写结构化良好的RESTful API。我将会详细介绍开发过程的常见模式和策略。</p> <p>我还将向你展示一些常见的框架和库的使用方式, 如 <a href="https://docs.microsoft.com/en-us/ef/core/" target="_blank" rel="noopener noreferrer">Entity Framework Core<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a href="https://automapper.org/" target="_blank" rel="noopener noreferrer">AutoMapper<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> , 来交付必要的功能。</p> <h2 id="先决条件"><a href="#先决条件" class="header-anchor">#</a> 先决条件</h2> <p>我假定你已经有面向对象编程概念的知识。</p> <p>虽然我将会复习很多关于 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/" target="_blank" rel="noopener noreferrer">C# programming language<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的细节, 我建议你对这一门语言有基础的理解。</p> <p>同时, 我也假定你知道什么是 REST、 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" target="_blank" rel="noopener noreferrer">HTTP 协议<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是如何工作的、什么是 API endpoints (路径又称&quot;终点&quot;) 以及 <a href="https://www.json.org/" target="_blank" rel="noopener noreferrer">JSON<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是什么。这里有一个关于这方面的 <a href="https://medium.freecodecamp.org/restful-services-part-i-http-in-a-nutshell-aab3bfedd131" target="_blank" rel="noopener noreferrer">入门教程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。最后一个要求是了解关系型数据库是如何工作。</p> <p>跟我一起编写代码, 你必须先安装 <a href="https://dotnet.microsoft.com/download" target="_blank" rel="noopener noreferrer">.NET Core 2.2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, 以及 <a href="https://www.getpostman.com/" target="_blank" rel="noopener noreferrer">Postman<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> , Postman 工具的作用是测试 API。我建议你使用代码编辑器(如 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener noreferrer">Visual Studio Code<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> )来开发API。选择你最喜欢的代码编辑器。如果你选择 VS code , 我建议你安装 <a href="https://code.visualstudio.com/docs/languages/csharp" target="_blank" rel="noopener noreferrer">C# extension<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> , 它会让你拥有更好的代码高亮效果。</p> <p>你可以在本文最后找到一个本篇教程的配套代码的 GitHub 仓库链接, 以检查最终结果。</p> <h2 id="the-scope"><a href="#the-scope" class="header-anchor">#</a> The Scope</h2> <p>让我们为一个超市写一个虚拟的 web API. 假设我们要实现以下功能:</p> <ul><li><em>创建一个 RESTful 服务, 它允许客户端应用程序管理超市的产品分类, 它需要暴露一个路径(API)来增删改查产品分类, 例如奶制品和化妆品, 并同时管理这些产品的类别。</em></li> <li><em>对于分类, 我们需要存储它们的名称。对于产品, 我们需要存储它们的名称、计量单位(比如, KG为产品的重量)、包装数量(比如, 10 如果产品是一包饼干)以及它们各自的类别。</em></li></ul> <p>为了简化这个例子, 我不会处理库存产品，产品运输，安全和任何其他功能。给定的需求已经足以向你展示 ASP.NET Core 是如何工作的。</p> <p>在开发这个服务之前, 我们基本上需要两个 API endpoints: 一个管理分类, 另一个管理产品。在JSON通信方面，我们可以将响应看作如下:</p> <p><strong>API endpoint:</strong> <code>/api/categories</code></p> <p><strong>JSON 响应(GET请求):</strong></p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Fruits and Vegetables&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Breads&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    … <span class="token comment">// Other categories</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>API endpoint:</strong> <code>/api/products</code></p> <p><strong>JSON 响应(GET请求):</strong></p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Sugar&quot;</span><span class="token punctuation">,</span>
      <span class="token property">&quot;quantityInPackage&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token property">&quot;unitOfMeasurement&quot;</span><span class="token operator">:</span> <span class="token string">&quot;KG&quot;</span>
      <span class="token property">&quot;category&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
        <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Sugar&quot;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    … <span class="token comment">// Other products</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>让我们开始编写这个应用吧.</p> <h2 id="步骤1-创建-api"><a href="#步骤1-创建-api" class="header-anchor">#</a> 步骤1 - 创建 API</h2> <p>首先, 我们必须为这个web服务创建一个目录结构, 然后我们需要使用 <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/?tabs=netcore2x" target="_blank" rel="noopener noreferrer">.NET CLI tools<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 脚手架构建一个 web API。打开终端或者命令行(取决于你使用的操作系统)依次输入下列的命令:</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mkdir</span> src/Supermarket.API

<span class="token builtin class-name">cd</span> src/Supermarket.API

dotnet new webapi
</code></pre></div><p>前两个命令只是为了API创建一个新的目录, 并将当前位置更改为新创建的目录。最后一个命令根据 Web API 模板创建一个项目, 这就是我们将要开发的应用程序。你可以通过这个<a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new?tabs=netcore21" target="_blank" rel="noopener noreferrer">链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>阅读更多的关于这些命令和其他的可以创建的项目模板</p> <p>新建的目录现在将会有如下的结构:</p> <p><img src="/images/netcore/restful-api-1.png" alt="项目结构"></p> <h4 id="结构概述"><a href="#结构概述" class="header-anchor">#</a> 结构概述</h4> <p>一个 ASP.NET Core 应用程序由一组在 <code>Startup</code> 类中配置的<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.2" target="_blank" rel="noopener noreferrer">中间件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>(附加到应用程序管道的小应用程序片段, 用于处理请求和响应)组成。如果你以前已经使用过 <a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer">Express.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 这样的框架, 那么这个概念对你来说并不陌生。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Startup</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Startup</span><span class="token punctuation">(</span><span class="token class-name">IConfiguration</span> configuration<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Configuration <span class="token operator">=</span> configuration<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">IConfiguration</span> Configuration <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment">// This method gets called by the runtime. Use this method to add services to the container.</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ConfigureServices</span><span class="token punctuation">(</span><span class="token class-name">IServiceCollection</span> services<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        services<span class="token punctuation">.</span><span class="token function">AddMvc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetCompatibilityVersion</span><span class="token punctuation">(</span>CompatibilityVersion<span class="token punctuation">.</span>Version_2_2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Configure</span><span class="token punctuation">(</span><span class="token class-name">IApplicationBuilder</span> app<span class="token punctuation">,</span> <span class="token class-name">IHostingEnvironment</span> env<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>env<span class="token punctuation">.</span><span class="token function">IsDevelopment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            app<span class="token punctuation">.</span><span class="token function">UseDeveloperExceptionPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.</span>
            app<span class="token punctuation">.</span><span class="token function">UseHsts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        app<span class="token punctuation">.</span><span class="token function">UseHttpsRedirection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        app<span class="token punctuation">.</span><span class="token function">UseMvc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当应用程序开始运行,  <code>Program</code> 类中的 <code>Main</code> 方法首先被调用。它使用启动配置创建一个默认的 web 主机，通过一个特定的端口提供HTTP服务 (默认情况下，HTTP使用5000端口, 5001用于HTTPS)。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Program</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">CreateWebHostBuilder</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">IWebHostBuilder</span> <span class="token function">CreateWebHostBuilder</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
            WebHost<span class="token punctuation">.</span><span class="token function">CreateDefaultBuilder</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token generic-method"><span class="token function">UseStartup</span><span class="token punctuation">&lt;</span><span class="token class-name">Startup</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>看一看在 <code>Controllers</code> 目录中的 <code>ValuesController</code> 类, 它公开当 API 通过路由 <code>/api/values</code> 接收请求时将调用的方法。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token class-name">Route</span><span class="token punctuation">(</span><span class="token string">&quot;api/[controller]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token class-name">ApiController</span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ValuesController</span> <span class="token punctuation">:</span> <span class="token class-name">ControllerBase</span>
<span class="token punctuation">{</span>
    <span class="token comment">// GET api/values</span>
    <span class="token punctuation">[</span><span class="token class-name">HttpGet</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> ActionResult<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">&gt;&gt;</span> <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token string">&quot;value1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;value2&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// GET api/values/5</span>
    <span class="token punctuation">[</span><span class="token class-name">HttpGet</span><span class="token punctuation">(</span><span class="token string">&quot;{id}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> ActionResult<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">&gt;</span> <span class="token function">Get</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;value&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// POST api/values</span>
    <span class="token punctuation">[</span><span class="token class-name">HttpPost</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Post</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">FromBody</span><span class="token punctuation">]</span> <span class="token keyword">string</span> <span class="token keyword">value</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> 
    <span class="token punctuation">}</span>

    <span class="token comment">// PUT api/values/5</span>
    <span class="token punctuation">[</span><span class="token class-name">HttpPut</span><span class="token punctuation">(</span><span class="token string">&quot;{id}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Put</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token class-name">FromBody</span><span class="token punctuation">]</span> <span class="token keyword">string</span> <span class="token keyword">value</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>   
    <span class="token punctuation">}</span>

    <span class="token comment">// DELETE api/values/5</span>
    <span class="token punctuation">[</span><span class="token class-name">HttpDelete</span><span class="token punctuation">(</span><span class="token string">&quot;{id}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>  
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果你不理解上面代码的某个部分, 别担心。我将在开发必要的API endpoints时详细介绍每个点。现在，简单地删除这个类，因为我们不打算使用它。</p> <h2 id="步骤2-创建领域模型"><a href="#步骤2-创建领域模型" class="header-anchor">#</a> 步骤2 - 创建领域模型</h2> <p>我将应用一些设计概念，使得应用程序能保持简单且易于维护。</p> <p>编写自己能够理解和维护的代码并不困难，但是你必须记住，你会作为团队的一份子去工作。如果你不注意如何编写代码，结果将会很可怕，它会让你和你的团队非常头痛。这件事听起来很极端，对吧? 但是相信我，这是事实。</p> <p><img src="/images/netcore/restful-api-2.png" alt="代码可维护性"></p> <p><a href="https://www.flickr.com/photos/smitty/2245445147" target="_blank" rel="noopener noreferrer">wtf — code quality measurement<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> by <a href="https://www.flickr.com/photos/smitty/" target="_blank" rel="noopener noreferrer">smitty42<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> is licensed under <a href="https://creativecommons.org/licenses/by-nd/2.0/" target="_blank" rel="noopener noreferrer">CC-BY-ND 2.0<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>让我们开始编写领域层, 该层会有我们的模型类, 这些类用来表示我们的产品和分类, 以及仓储层和服务层的接口类型。稍后我将会解释这两个概念。</p> <p>在 <code>Supermarket.API</code> 这个目录中, 创建一个名为 <code>Domaind</code> 的文件夹。同时在这个新的领域文件夹中, 新建另一个名为 <code>Models</code> 的文件夹。我们需要添加到这个文件夹的第一个模型是 <code>Category</code>。起初, 它只是一个简单的老式 CLR 对象类(<a href="https://en.wikipedia.org/wiki/Plain_old_CLR_object" target="_blank" rel="noopener noreferrer">POCO<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)。这意味着该类将只有描述其基本信息的属性。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Category</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> Id <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">string</span> Name <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">public</span> IList<span class="token operator">&lt;</span>Product<span class="token operator">&gt;</span> Products <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-method"><span class="token function">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Product</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个类有一个 <code>Id</code> 属性去区分列别, 和一个 <code>Name</code> 属性, 以及一个 <code>Products</code> 属性。最后一个将由 <strong>Entity Framework Core</strong> 使用, 它是 ASP.NET Core 中最常见的数据持久化 <strong>ORM</strong> 工具, 用来映射产品和类别之间的关系。从面向对象编程的角度来看, 它是很有意义的, 因为一个类别会有许多个相关产品。</p> <p>我们还需要在相同的目录下创建一个产品模型类, 添加一个新的 <code>Product</code> 类。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> Id <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">string</span> Name <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">short</span> QuantityInPackage <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token class-name">EUnitOfMeasurement</span> UnitOfMeasurement <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">int</span> CategoryId <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token class-name">Category</span> Category <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>产品同样拥有 Id 和 Name 两个属性。<code>QuantityInPackage</code> 属性表示一包产品中含有多少个单元(记得 Scope 中的饼干示例), 以及一个 <code>UnitOfMeasurement</code> 属性。这个属性用一个<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum" target="_blank" rel="noopener noreferrer">枚举类型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来表示可能的度量单位。最后两个属性, <code>CategoryId</code> 和 <code>Category</code> 将会被 ORM 用来映射产品和类别之间的关系。它表示一个产品只有一个类别。</p> <p>让我们一起定义最后一个领域模型中的部分, <code>EUnitOfMeasurement</code> 枚举。</p> <p>按照惯例，enum不需要在名称前面以“E”开头，但是在一些库和框架中，你会发现这个前缀是区分enum与接口和类的一种方式。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> System<span class="token punctuation">.</span>ComponentModel<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">enum</span> EUnitOfMeasurement <span class="token punctuation">:</span> <span class="token keyword">byte</span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">[</span><span class="token class-name">Description</span><span class="token punctuation">(</span><span class="token string">&quot;UN&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        Unity <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>

        <span class="token punctuation">[</span><span class="token class-name">Description</span><span class="token punctuation">(</span><span class="token string">&quot;MG&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        Milligram <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>

        <span class="token punctuation">[</span><span class="token class-name">Description</span><span class="token punctuation">(</span><span class="token string">&quot;G&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        Gram <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>

        <span class="token punctuation">[</span><span class="token class-name">Description</span><span class="token punctuation">(</span><span class="token string">&quot;KG&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        Kilogram <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>

        <span class="token punctuation">[</span><span class="token class-name">Description</span><span class="token punctuation">(</span><span class="token string">&quot;L&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        Liter <span class="token operator">=</span> <span class="token number">5</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码非常直截了当。在这里，我们只定义了少量的度量单位的可能性，不过，在一个真正的超市系统中，你可能有许多其他的度量单位，并且可能有一个单独的模型。</p> <p>请注意 <code>Description</code> <a href="https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/concepts/attributes/" target="_blank" rel="noopener noreferrer">attribute<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 被应用在每个可能的枚举上。attribute是在c#语言的类、接口、属性和其他组件上定义元数据的一种方式。在本案例中, 我们会使用它来简化产品 API endpoint 的响应, 不过你现在不需要关心它。我们稍后再回来。</p> <p>我们的基本模型已经可供使用。现在我们可用开始编写 API endpoint 来管理所有的类别。</p> <h2 id="步骤3-类别-api"><a href="#步骤3-类别-api" class="header-anchor">#</a> 步骤3 - 类别 API</h2> <p>在 Controllers 目录中, 添加一个名为 <code>CategoriesController</code> 的类。</p> <p>通常情况下, 该目录下的所有以*“Controller”*结尾的类将会成为我们应用程序中的控制器。这意味着它们将会处理请求和响应。你必须从 <code>Controller</code> 这个类继承, 它在 <code>Microsoft.AspNetCore.Mvc</code> <a href="https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/namespace" target="_blank" rel="noopener noreferrer">命名空间<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中定义。</p> <p>名称空间由一组相关的类、接口、枚举和结构体组成。你可以将其看作类似于 Javascript 语言的<a href="https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc" target="_blank" rel="noopener noreferrer">modules<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>或Java的<a href="https://docs.oracle.com/javase/tutorial/java/package/packages.html" target="_blank" rel="noopener noreferrer">packages<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>这个新的控制器应该通过 <code>/api/categories</code> 这个路由来响应。我们通过在类的名称上添加 <code>Route</code> attribute 来实现这个功能, 根据惯例, 指定一个占位符, 指示路由应该使用没有控制器后缀的类名。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Mvc<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Controllers
<span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token class-name">Route</span><span class="token punctuation">(</span><span class="token string">&quot;/api/[controller]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CategoriesController</span> <span class="token punctuation">:</span> <span class="token class-name">Controller</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>让我们开始处理 GET 请求。首先, 当有人通过 GET 谓词从  <code>/api/categories</code> 请求数据时, API 需要返回所有的类别。我们可以为这个目的创建一个类别服务。</p> <p>从概念上讲，服务基本上是定义处理某些业务逻辑方法的类或接口。在许多不同的编程语言中，创建用于处理业务逻辑的服务是一种常见的方式，例如<a href="https://medium.com/@evandro.ggomes/json-web-token-authentication-with-asp-net-core-2-0-b074b0cfc870" target="_blank" rel="noopener noreferrer">身份验证和授权<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、支付、复杂的数据流、缓存以及需要在其他服务或模型之间进行某些交互的任务。</p> <p>使用服务，我们可以将请求和响应处理与完成任务所需的实际逻辑隔离开来。</p> <p>我们即将创建的服务会定义一个单一的职责或方法: 一个列表方法。我们希望这个方法返回数据库中的所有类别。</p> <p>为简单起见，在本例中我们不处理数据分页或过滤。我将在以后撰写一篇文章，介绍如何轻松地处理这些特性。</p> <p>在 C# 中定义一个预期的行为((在其他面向对象的语言中，例如Java)), 我们使用 <strong>interface</strong> 来定义。接口告诉我们要什么, 但是<strong>不实现其真正的逻辑</strong>。真正的实现逻辑在实现这个接口的类中。如果你不清楚这个概念，不要担心。你很快就会明白的。</p> <p>在 <code>Domain</code> 目录中, 创建一个名为 <code>Services</code> 的新文件夹。在其中添加一个名为 <code>ICategoryService</code> 的接口。按照惯例，所有接口都应该以 C# 中的大写字母 “I” 开头。接口代码定义如下:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Tasks<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Services
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ICategoryService</span>
    <span class="token punctuation">{</span>
         Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;&gt;</span> <span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实现 <code>ListAsync</code> 方法必须异步返回类别的枚举。</p> <p><code>Task</code> 类, 封装返回值, 表示异步。我们需要以异步方式思考，因为我们必须等待数据库完成一些操作来返回数据，而这个过程可能需要一段时间。还请注意“async”后缀。这是一个表明我们的方法应该异步执行的约定。</p> <p>我们有很多约定, 对吗? 我个人非常喜欢这种方式, 因为它保证应用程序的可读性, 即使你是一个使用.NET技术的公司的新人。</p> <p><em>“ - Ok, we defined this interface, but it does nothing. How can it be useful?”</em></p> <p>如果你刚从一个如 Javascript 或者其它非强类型语言转过来, 这些概念可能会比较陌生。</p> <p>接口允许我们从实际实现中抽象出所需的行为。使用一种已知的机制, 例如<a href="https://medium.freecodecamp.org/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f" target="_blank" rel="noopener noreferrer">依赖注入<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, 我们可以实现这些接口并将它们与其他组件隔离。</p> <p>通常情况下, 当你使用依赖注入时, 你需要通过接口定义一下行为。然后创建一个类去实现这个接口。最后, 将接口中的引用绑定到创建的类。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>这听起来很让人困惑。我们不能简单地创建一个类来为我们做这些事情吗?</p></div> <p>让我们继续实现我们的 API ,然后你会理解为什么我使用这种方式。</p> <p>按照以下的方式修改 <code>CategoriesController</code> 的代码:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Tasks<span class="token punctuation">;</span>
<span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Mvc<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Services<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Controllers
<span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token class-name">Route</span><span class="token punctuation">(</span><span class="token string">&quot;/api/[controller]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CategoriesController</span> <span class="token punctuation">:</span> <span class="token class-name">Controller</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">ICategoryService</span> _categoryService<span class="token punctuation">;</span>
        
        <span class="token keyword">public</span> <span class="token function">CategoriesController</span><span class="token punctuation">(</span><span class="token class-name">ICategoryService</span> categoryService<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            _categoryService <span class="token operator">=</span> categoryService<span class="token punctuation">;</span>   
        <span class="token punctuation">}</span>

        <span class="token punctuation">[</span><span class="token class-name">HttpGet</span><span class="token punctuation">]</span>
        <span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;&gt;</span> <span class="token function">GetAllAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">var</span> categories <span class="token operator">=</span> <span class="token keyword">await</span> _categoryService<span class="token punctuation">.</span><span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> categories<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我已经为我们的控制器定义了一个构造方法(在创建类的新实例构造函数会被调用), 它接受一个 <code>ICategoryService</code> 实例。这意味着这个实例可以是任何实现这个接口服务的类。我将这个实例存储在一个私有的只读字段 <code>_categoryService</code> 中。我们将使用此字段访问类别服务实现的方法。</p> <p>顺便说一下，下划线前缀是表示字段的另一种常见约定。特别提一下, 这个约定并不是 <a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions" target="_blank" rel="noopener noreferrer">.NET 官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 推荐的, 但这是一种非常常见的做法，它可以使用“This”关键字来区分类字段和局部变量。我个人认为它更易于阅读，很多框架和库都使用这种约定。</p> <p>结构体函数的下方, 我定义了一个处理请求 <code>/api/categories</code> 的方法。<code>HttpGet</code> 属性表示通知  ASP.NET Core 管道使用 <strong>GET</strong> 请求处理它(这个属性可以省略，但是为了便于阅读，最好编写它)。</p> <p>该方法使用 category 服务实例列出所有类别，然后将类别返回给客户端。框架管道处理数据, 并将其序列化成 JSON 对象。<code>IEnumerable&lt;Category&gt;</code> 类型告诉框架，我们想要返回一个类别的枚举，而 <code>Task</code> 类型之前的 <code>async</code> 关键字告诉管道，这个方法应该异步执行。最后，当我们定义一个异步方法时，我们必须使用 <code>await</code> 关键字来处理需要一些时间的任务。</p> <p>我们定义好了 API 的初始结构。现在，有必要真正实现 categories 服务。</p> <h2 id="步骤4-类别服务实现"><a href="#步骤4-类别服务实现" class="header-anchor">#</a> 步骤4 - 类别服务实现</h2> <p>在 API 的根目录中( <code>Supermarket.API</code> 目录 ), 创建一个名为 <code>Services</code> 的新文件夹。我们将把所有的服务实现放入其中。在新创建的文件夹中, 创建一个 <code>CategoryService</code> 类, 按照下面的代码进行修改。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Tasks<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Services<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Services
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CategoryService</span> <span class="token punctuation">:</span> <span class="token class-name">ICategoryService</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;&gt;</span> <span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它只是接口实现的基本代码，但我们仍然不处理任何逻辑。让我们考虑一下列表方法应该如何工作。</p> <p>我们需要去访问数据库并返回所有的类别, 然后我需要将这些数据返回给客户端。</p> <p>服务类不是应该处理数据访问的类。这是一种称为<a href="https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design#the-repository-pattern" target="_blank" rel="noopener noreferrer">仓储模式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的模式，用于管理数据库中的数据。</p> <p>当我们使用仓储模式, 我们需要定义一个 <strong>仓储类</strong> , 它基本上封装了处理数据访问的所有逻辑。这些仓储库公开方法来列出、创建、编辑和删除给定模型的对象，与操作<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/collections" target="_blank" rel="noopener noreferrer">集合<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的方式相同。在内部，这些方法与数据库通信以执行CRUD操作，它将数据库访问与应用程序的其他部分隔离开来。</p> <p>我们的服务需要与类别仓储进行通信, 以获得对象的集合。</p> <p>通常情况下, 一个服务可以调用一个或者多个仓储, 以及其它的服务去执行操作。</p> <p>创建一个处理数据访问逻辑的定义可能看起来有些多余，但是你会在一段时间内看到，将这个逻辑与服务类隔离确实很有好处。</p> <p>让我们创建一个仓储库，它负责持久化类别的一种方式来仲裁数据库通信。</p> <h2 id="步骤5-类别仓储与持久层"><a href="#步骤5-类别仓储与持久层" class="header-anchor">#</a> 步骤5 - 类别仓储与持久层</h2> <p>在 <code>Domain</code> 目录中, 新建一个 <code>Repositories</code> 新文件夹。然后, 新建一个名为 <code>ICategoryRespository</code> 的接口类。以如下的方式定义一个接口。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Tasks<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Repositories
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ICategoryRepository</span>
    <span class="token punctuation">{</span>
         Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;&gt;</span> <span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>初始代码与服务接口的代码基本相同。</p> <p>当有了这个接口, 我们回到服务类中并开始实现集合方法, 使用 <code>ICategoryRepository</code> 的实例去返回数据。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Tasks<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Repositories<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Services<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Services
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CategoryService</span> <span class="token punctuation">:</span> <span class="token class-name">ICategoryService</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">ICategoryRepository</span> _categoryRepository<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">CategoryService</span><span class="token punctuation">(</span><span class="token class-name">ICategoryRepository</span> categoryRepository<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>_categoryRepository <span class="token operator">=</span> categoryRepository<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;&gt;</span> <span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span> 
            <span class="token keyword">return</span> <span class="token keyword">await</span> _categoryRepository<span class="token punctuation">.</span><span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在, 我们必须类别仓储中的真正逻辑。在这之前, 我们必须先考虑我们如何去访问数据库。</p> <p>是的, 我们仍然还没有数据库!</p> <p>我们将使用 Entity Framework Core (为了简单, 我将之称为 <code>EF Core</code>) 作为我们的数据库 ORM。这个框架附带了ASP.NET Core 作为其默认的ORM，并且 API 支持友好的，允许我们将应用程序的类映射到数据库表。</p> <p>EF Core 允许我们先设计应用程序, 然后根据我们在代码中定义的内容生成一个数据库。这种技术称为 <code>code first</code> 。我们将使用 code first 方法来生成数据库(在本例中，实际上我将使用内存数据库，但是你可以轻松地将其更改为 SQL 服务器或 MySQL 服务器实例)。</p> <p>在 API 根目录中, 创建一个名为 <code>Persistence</code> 的文件夹。这个文件夹将包含所有我们访问数据库的内容, 比如仓储层的实现。</p> <p>在这个新目录中, 创建一个新文件夹 <code>Contexts</code>, 然后添加一个 <code>AppDbContext</code> 类。这个类必须继承 <code>DbContext</code> , 它是 EF Core 用来映射你的模型到数据库表的类。修改代码如下:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>EntityFrameworkCore<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Persistence<span class="token punctuation">.</span>Contexts
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppDbContext</span> <span class="token punctuation">:</span> <span class="token class-name">DbContext</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token function">AppDbContext</span><span class="token punctuation">(</span>DbContextOptions<span class="token operator">&lt;</span>AppDbContext<span class="token operator">&gt;</span> options<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们添加到这个类的构造函数负责通过依赖项注入将数据库配置传递给基类。过一会儿你就会明白这是怎么回事。</p> <p>现在, 我们需要创建两个 <code>DbSet</code> 属性, 这些属性是将模型映射到数据库表的集合(惟一对象的集合)。</p> <p>同时, 我们必须将模型的属性映射到相应的表列, 指定哪些属性是主键, 哪些是外健, 列表类型等等。我们可以使用 <a href="http://www.entityframeworktutorial.net/efcore/fluent-api-in-entity-framework-core.aspx" target="_blank" rel="noopener noreferrer">Fluent API<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的特性来指定数据库映射，从而重写 <code>OnModelCreating</code> 方法。更改 <code>AppDbContext</code> 类如下:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>EntityFrameworkCore<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Persistence<span class="token punctuation">.</span>Contexts
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppDbContext</span> <span class="token punctuation">:</span> <span class="token class-name">DbContext</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> DbSet<span class="token operator">&lt;</span>Category<span class="token operator">&gt;</span> Categories <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">public</span> DbSet<span class="token operator">&lt;</span>Product<span class="token operator">&gt;</span> Products <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token function">AppDbContext</span><span class="token punctuation">(</span>DbContextOptions<span class="token operator">&lt;</span>AppDbContext<span class="token operator">&gt;</span> options<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

        <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">OnModelCreating</span><span class="token punctuation">(</span><span class="token class-name">ModelBuilder</span> builder<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnModelCreating</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Category</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToTable</span><span class="token punctuation">(</span><span class="token string">&quot;Categories&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Category</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HasKey</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>Id<span class="token punctuation">)</span><span class="token punctuation">;</span>
            builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Category</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>Id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ValueGeneratedOnAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Category</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HasMaxLength</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Category</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HasMany</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>Products<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">WithOne</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>Category<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HasForeignKey</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>CategoryId<span class="token punctuation">)</span><span class="token punctuation">;</span>

            builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Category</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>HasData
            <span class="token punctuation">(</span>
                <span class="token keyword">new</span> <span class="token class-name">Category</span> <span class="token punctuation">{</span> Id <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> Name <span class="token operator">=</span> <span class="token string">&quot;Fruits and Vegetables&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// Id set manually due to in-memory provider</span>
                <span class="token keyword">new</span> <span class="token class-name">Category</span> <span class="token punctuation">{</span> Id <span class="token operator">=</span> <span class="token number">101</span><span class="token punctuation">,</span> Name <span class="token operator">=</span> <span class="token string">&quot;Dairy&quot;</span> <span class="token punctuation">}</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>

            builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Product</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToTable</span><span class="token punctuation">(</span><span class="token string">&quot;Products&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Product</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HasKey</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>Id<span class="token punctuation">)</span><span class="token punctuation">;</span>
            builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Product</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>Id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ValueGeneratedOnAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Product</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HasMaxLength</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Product</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>QuantityInPackage<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Product</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>UnitOfMeasurement<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们指定了模型应该映射到哪些表。同时, 我们使用了 <code>HasKey</code> 设置了主键, 使用 <code>Property</code> 方法设置表列, 和一些约束如:  <code>IsRequired</code>,  <code>HasMaxLength</code> 和 <code>ValueGeneratedOnAdd</code>, 所有都是用 “流畅的方式” <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions" target="_blank" rel="noopener noreferrer">lambda 表达式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> (链式方式)。</p> <p>看下面这段代码:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code>builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Category</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">HasMany</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>Products<span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">WithOne</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>Category<span class="token punctuation">)</span>
       <span class="token punctuation">.</span><span class="token function">HasForeignKey</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>CategoryId<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里我们指定了表之间的关系。我们说一个类别具有多个产品, 我们设置了映射这个关系的属性( <code>Products</code> 来自 <code>Category</code> 类, 而 <code>Category</code> 来自 <code>Product</code> 类。同时, 我们还设置了一个外健( <code>CategoryId</code> )。</p> <p>如果你想学习如何使用 <code>EF Core</code> 来配置一对一或多对多之间的关系, 可以看一下这个<a href="https://www.learnentityframeworkcore.com/relationships" target="_blank" rel="noopener noreferrer">教程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, 以及如何将其作为一个整体使用。</p> <p>这里还有一种生成数据的配置方式, 通过 <code>HasData</code> 来:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code>builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Category</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>HasData

<span class="token punctuation">(</span>
  <span class="token keyword">new</span> <span class="token class-name">Category</span> <span class="token punctuation">{</span> Id <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> Name <span class="token operator">=</span> <span class="token string">&quot;Fruits and Vegetables&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">new</span> <span class="token class-name">Category</span> <span class="token punctuation">{</span> Id <span class="token operator">=</span> <span class="token number">101</span><span class="token punctuation">,</span> Name <span class="token operator">=</span> <span class="token string">&quot;Dairy&quot;</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在这里, 我们简单的添加了两个示例类别。这是在我们完成 API 接口后用来测试接口所必需的条件。</p> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>我们在这里手动设置了 Id 属性，因为内存数据库需要它才能工作。我将标识符设置为大数字，以避免自动生成的标识符和种子数据之间的冲突。</p> <p>这种限制在真正的关系数据库中并不存在，因此，如果你使用 SQL Server 之类的数据库，就不必指定这些标识符。如果你想了解这种行为，可以自行查看这个 <a href="https://github.com/aspnet/EntityFrameworkCore/issues/6872" target="_blank" rel="noopener noreferrer">Github issue<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></div> <p>在实现了数据库上下文类之后，我们可以实现类别仓储层。在 <code>Persistence</code> 目录中新建一个名为 <code>Repositories</code> 的新文件夹, 然后新建一个 <code>BaseRepository</code> 类:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Persistence<span class="token punctuation">.</span>Contexts<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Persistence<span class="token punctuation">.</span>Repositories
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BaseRepository</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">protected</span> <span class="token keyword">readonly</span> <span class="token class-name">AppDbContext</span> _context<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">BaseRepository</span><span class="token punctuation">(</span><span class="token class-name">AppDbContext</span> context<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            _context <span class="token operator">=</span> context<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个类仅是一个<strong>抽象类</strong>, 供所有的仓储层类去继承。抽象类是无法实例化的类。你必须实例化一个类来使用它。</p> <p><code>BaseRepository</code> 通过依赖项注入接收 <code>AppDbContext</code> 的实例，并公开一个名为 <code>_context</code> 的受保护属性(该属性只能由子类访问)，该属性允许访问处理数据库操作所需的所有方法。</p> <p>在同一个文件夹中添加一个名为 <code>CategoryRepository</code> 新类。现在我们来真正实现仓储层的逻辑:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Tasks<span class="token punctuation">;</span>
<span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>EntityFrameworkCore<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Repositories<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Persistence<span class="token punctuation">.</span>Contexts<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Persistence<span class="token punctuation">.</span>Repositories
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CategoryRepository</span> <span class="token punctuation">:</span> <span class="token class-name">BaseRepository</span><span class="token punctuation">,</span> ICategoryRepository
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token function">CategoryRepository</span><span class="token punctuation">(</span><span class="token class-name">AppDbContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;&gt;</span> <span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">await</span> _context<span class="token punctuation">.</span>Categories<span class="token punctuation">.</span><span class="token function">ToListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个仓储层类继承了基类 <code>BaseRepository</code> 并实现了 <code>ICategoryRepository</code> 接口。</p> <p>你可能注意到列表方法的实现是如此简单。我们使用 <code>Categories</code> 数据库去访问类别表并且调用 <code>ToListAsync</code> 扩展方法, 这个方法负责将查询结果转换成类别集合。</p> <p>EF Core 将我们的方法调用<a href="https://docs.microsoft.com/en-us/ef/core/querying/overview" target="_blank" rel="noopener noreferrer">转换成 SQL 查询语句<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, 以最优的方法。只有在调用将数据转换为集合的方法或使用方法获取特定数据时，查询才会执行。</p> <p>我们现在有一个简洁的类别控制器实现, 以及服务和仓储层。</p> <p>我们已经将关注点分离，创建了只做它们应该做的事情的类。</p> <p>测试应用程序之前的最后一步是使用 ASP.NET Core 依赖注入机制将我们的接口绑定到相应的类。</p> <h2 id="步骤6-配置依赖注入"><a href="#步骤6-配置依赖注入" class="header-anchor">#</a> 步骤6 - 配置依赖注入</h2> <p>现在是你最终理解这个概念如何工作的时候了。</p> <p>在应用程序的根目录中, 打开 <code>Startup</code> 类。这个类负责在应用程序启动时配置所有类型的配置。</p> <p>框架管道在运行时调用 <code>ConfigureServices</code> 和 <code>Configure</code> 方法, 以配置应用程序应该如何工作以及它必须使用哪些组件。</p> <p>让我们看一看 <code>ConfigureServices</code> 方法。这里我们只有一行代码来配置应用程序去使用 MVC 管道,  这基本上意味着应用程序将使用控制器类来处理请求和响应(这里有更多底层处理的事情，但这不是你现在需要知道的)。</p> <p>我们可以使用 <code>ConfigureServices</code> 方法, 访问 <code>services</code> 参数并配置我们的依赖注入绑定。清除类代码，删除所有注释，修改代码如下:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Builder<span class="token punctuation">;</span>
<span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Hosting<span class="token punctuation">;</span>
<span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Mvc<span class="token punctuation">;</span>
<span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>EntityFrameworkCore<span class="token punctuation">;</span>
<span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>Extensions<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span>
<span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>Extensions<span class="token punctuation">.</span>DependencyInjection<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Repositories<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Services<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Persistence<span class="token punctuation">.</span>Contexts<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Persistence<span class="token punctuation">.</span>Repositories<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Services<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Startup</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">IConfiguration</span> Configuration <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token function">Startup</span><span class="token punctuation">(</span><span class="token class-name">IConfiguration</span> configuration<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            Configuration <span class="token operator">=</span> configuration<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ConfigureServices</span><span class="token punctuation">(</span><span class="token class-name">IServiceCollection</span> services<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            services<span class="token punctuation">.</span><span class="token function">AddMvc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetCompatibilityVersion</span><span class="token punctuation">(</span>CompatibilityVersion<span class="token punctuation">.</span>Version_2_2<span class="token punctuation">)</span><span class="token punctuation">;</span>

            services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddDbContext</span><span class="token punctuation">&lt;</span><span class="token class-name">AppDbContext</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>options <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                options<span class="token punctuation">.</span><span class="token function">UseInMemoryDatabase</span><span class="token punctuation">(</span><span class="token string">&quot;supermarket-api-in-memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddScoped</span><span class="token punctuation">&lt;</span><span class="token class-name">ICategoryRepository</span><span class="token punctuation">,</span> <span class="token class-name">CategoryRepository</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddScoped</span><span class="token punctuation">&lt;</span><span class="token class-name">ICategoryService</span><span class="token punctuation">,</span> <span class="token class-name">CategoryService</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Configure</span><span class="token punctuation">(</span><span class="token class-name">IApplicationBuilder</span> app<span class="token punctuation">,</span> <span class="token class-name">IHostingEnvironment</span> env<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>env<span class="token punctuation">.</span><span class="token function">IsDevelopment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                app<span class="token punctuation">.</span><span class="token function">UseDeveloperExceptionPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{</span>
                <span class="token comment">// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.</span>
                app<span class="token punctuation">.</span><span class="token function">UseHsts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            app<span class="token punctuation">.</span><span class="token function">UseHttpsRedirection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            app<span class="token punctuation">.</span><span class="token function">UseMvc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>让我们观察这一段代码:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code>services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddDbContext</span><span class="token punctuation">&lt;</span><span class="token class-name">AppDbContext</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>options <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>

  options<span class="token punctuation">.</span><span class="token function">UseInMemoryDatabase</span><span class="token punctuation">(</span><span class="token string">&quot;supermarket-api-in-memory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里我们配置来一个数据库上下文。我们告诉 ASP.NET Core 将我们的 <code>AppDbContext</code> 与我们的内存中的数据库实现一起使用, 该实现由作为参数传递给我们的方法的字符串标识。通常, 在编写<a href="https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-2.2" target="_blank" rel="noopener noreferrer">集成测试<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>时使用内存中的数据库, 但是为了简单起见, 我在这里使用它。通过这种方式, 我们不需要连接到真实的数据库来测试应用程序。</p> <p>这些行在内部配置我们的数据库上下文，以便使用确定<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2#service-lifetimes-and-registration-options" target="_blank" rel="noopener noreferrer">作用域<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的生存周期进行依赖项注入。</p> <p>作用域的生存周期告诉 ASP.NET Core 管道, 每当它需要解析一个类, 这个类接收 <code>AppDbContext</code> 的实例作为构造函数参数时, 它应该使用类的相同实例。如果内存中没有实例, 则管道将创建一个新实例, 并在给定请求期间在需要它的所有类中重用它。通过这种方式, 你不必在每次使用这类的时候都实例化这个类。</p> <p>这里有其他的生命周期, 你可以在<a href="https://docs.microsoft.com/pt-br/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2" target="_blank" rel="noopener noreferrer">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中查阅。</p> <p>依赖注入技术带给了我们很多好处，比如:</p> <ul><li>代码重用性;</li> <li>更好的生产力，因为当我们不得不改变实现的时候，我们不需要麻烦的去改变你使用那个特性的一百多个地方;</li> <li>你可以轻易测试你的应用程序, 因为我们可以使用 <strong>mock</strong> (类的假实现)来隔离需要测试的内容，在 mock 中，我们必须将接口作为构造函数参数传递;</li> <li>当类需要通过构造函数接收更多依赖项时，你不必手动更改创建实例的所有位置(这太棒了!)</li></ul> <p>当配置好数据库上下文时, 我们还将服务和存储库绑定到相应的类。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code>services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddScoped</span><span class="token punctuation">&lt;</span><span class="token class-name">ICategoryRepository</span><span class="token punctuation">,</span> <span class="token class-name">CategoryRepository</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddScoped</span><span class="token punctuation">&lt;</span><span class="token class-name">ICategoryService</span><span class="token punctuation">,</span> <span class="token class-name">CategoryService</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里我们使用作用域生命周期, 因为这些类内部必须使用数据库的上下文。在这种情况下, 指定相同的范围是有意义的。</p> <p>现在我们配置了依赖绑定, 我们还需要在 <code>Program</code> 类中做一点小的改动, 以便我们的数据库能正确的初始化。这一步仅仅在使用内存数据库时需要(查看这个 <a href="https://github.com/aspnet/EntityFrameworkCore/issues/11666" target="_blank" rel="noopener noreferrer">Github issue<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 能知道原因)。</p> <p>我们有必要更改 <code>Main</code> 方法，以确保在应用程序启动时“创建”数据库，因为我们使用的是内存提供程序。没有这个更改，我们想要创建的类别就不会创建。</p> <p>实现了所有的基本特性之后，就可以测试我们的 API 端点了。</p> <h2 id="步骤7-测试分类的-api"><a href="#步骤7-测试分类的-api" class="header-anchor">#</a> 步骤7 - 测试分类的 API</h2> <p>打开 API 根目录中的终端或命令提示符，输入以下命令:</p> <div class="language- extra-class"><pre class="language-text"><code>dotnet run
</code></pre></div><p>这个命令</p> <p>上面的命令启动应用程序。控制台将显示一个类似这样的输出:</p> <div class="language- extra-class"><pre class="language-text"><code>info: Microsoft.EntityFrameworkCore.Infrastructure[10403]
Entity Framework Core 2.2.0-rtm-35687 initialized ‘AppDbContext’ using provider ‘Microsoft.EntityFrameworkCore.InMemory’ with options: StoreName=supermarket-api-in-memory
info: Microsoft.EntityFrameworkCore.Update[30100]
Saved 2 entities to in-memory store.
info: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[0]
User profile is available. Using ‘C:\Users\evgomes\AppData\Local\ASP.NET\DataProtection-Keys’ as key repository and Windows DPAPI to encrypt keys at rest.
Hosting environment: Development
Content root path: C:\Users\evgomes\Desktop\Tutorials\src\Supermarket.API
Now listening on: https://localhost:5001
Now listening on: http://localhost:5000
Application started. Press Ctrl+C to shut down.
</code></pre></div><p>你可以看到 <strong>EF Core</strong> 被调用去初始化数据库。最后一行展示了应用程序运行在哪个端口上。</p> <p>打开浏览器并导航到 http://localhost:5000/api/categories (或导航到控制台输出中显示的URL)。如果你看到由于HTTPS而导致的安全错误，只需为应用程序添加一个异常。</p> <p>浏览器将显示以下JSON数据作为输出:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
     <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
     <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Fruits and Vegetables&quot;</span><span class="token punctuation">,</span>
     <span class="token property">&quot;products&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
     <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> <span class="token number">101</span><span class="token punctuation">,</span>
     <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Dairy&quot;</span><span class="token punctuation">,</span>
     <span class="token property">&quot;products&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre></div><p>这里我们看到的是在配置数据库上下文时添加到数据库中的数据。这个输出确认了我们的代码可以正常工作。</p> <p>你用几行代码就创建了一个GET API，并且由于API的体系结构，你有一个非常容易更改的代码结构。</p> <p>现在，向你展示当你必须根据业务需求进行调整时，更改这段代码是多么容易。</p> <h2 id="步骤8-创建一个分类资源"><a href="#步骤8-创建一个分类资源" class="header-anchor">#</a> 步骤8 - 创建一个分类资源</h2> <p>如果你还记得 API endpoint 的规范，你应该注意到了我们的实际 JSON 响应有一个额外属性：<strong>一个产品数组</strong>。让我们来看一下期望响应的例子：</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Fruits and Vegetables&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Breads&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    … <span class="token comment">// Other categories</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为我们的类别模型有一个 <strong>Products</strong> 属性，products 数组出现在我们当前的 JSON 响应中，<strong>EF Core</strong> 需要这个属性来纠正给定类别的产品映射。</p> <p>我们不想这个属性在我们的响应中，但是我们不能修改我们的模型类去删除这个属性。这样会导致 <strong>EF Core</strong> 在我们试图管理类别数据时抛出异常，这也会破坏我们的领域模型设计，因为没有产品的产品类别是没有意义的。</p> <p>要返回只包含超市类别的标识符和名称的 JSON 数据，我们必须创建一个 <strong>resource</strong> 类。</p> <p><strong><a href="https://restful-api-design.readthedocs.io/en/latest/resources.html" target="_blank" rel="noopener noreferrer">resource类<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></strong> 是一个只包含客户机应用程序和API端点之间交换的基本信息的类，通常以JSON数据的形式表示一些特定信息。</p> <p>来自 <strong>API</strong> 端点的所有响应都<strong>必须</strong>返回一个资源。</p> <p>响应直接返回实体模型是一个糟糕的实践, 因为它可能包含客户端应用程序不需要或者它没有权限获取的信息(例如, 一个用户模型的可能返回用户密码信息, 这是一个严重的安全问题)。</p> <p>我们需要一个资源去表示仅仅只有我们的分类, 而没有产品。</p> <p>现在你知道我们要的资源是什么了, 让我们实现它。首先, 在命令行按 <strong>Ctrl + C</strong> 停止正在运行的应用程序。在应用的根目录文件夹, 创建一个名为 <code>Resources</code> 的文件夹。然后, 创建一个 <code>CategoryResource</code> 类。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Resources
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CategoryResource</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> Id <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">string</span> Name <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们必须将类别服务提供的类别模型集合映射到类别资源集合中。</p> <p>我们将会一个叫做 <a href="https://automapper.org/" target="_blank" rel="noopener noreferrer"><strong>AutoMapper</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的库, 它能处理两个对象之间的映射。AutoMapper 是 .NET 世界中非常流行的库，许多商业和开源项目中都在使用它。</p> <p>将下列的行输入到命令行中, 将 AutoMapper 添加到我们的应用中。</p> <div class="language- extra-class"><pre class="language-text"><code>dotnet add package AutoMapper
dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection
</code></pre></div><p>在使用 AutoMapper 之前, 我们必须先做下面的两件事:</p> <ul><li>以依赖注入的方式将其注册;</li> <li>创建一个类, 告诉 AutoMapper 如何去处理类之间的映射关系。</li></ul> <p>首先, 打开 <code>Startup</code> 类。在 <code>ConfigureServices</code> 方法, 在最后一个行, 添加下面的代码:</p> <p><code>services.AddAutoMapper();</code></p> <p>这一行处理 AutoMapper 的所有必要配置，比如以依赖注入注册它，以及在启动期间扫描应用程序以配置映射配置文件。</p> <p>现在, 在根文件夹, 创建一个新的文件夹 <code>Mapping</code> , 然后创建一个类 <code>ModelToResourceProfile</code> 。修改代码如下:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> AutoMapper<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Resources<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Mapping
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ModelToResourceProfile</span> <span class="token punctuation">:</span> <span class="token class-name">Profile</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token function">ModelToResourceProfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token generic-method"><span class="token function">CreateMap</span><span class="token punctuation">&lt;</span><span class="token class-name">Category</span><span class="token punctuation">,</span> <span class="token class-name">CategoryResource</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个类继承自 <code>Profile</code>, 是AutoMapper用来检查映射如何工作的类类型。在构造函数中, 我们创建一个 <code>Category</code> 模型类和 <code>CategoryResource</code> 类之间的映射。由于类的属性具有相同的名称和类型，我们不需要为它们进行任何特殊的配置。</p> <p>最后一步是将 categories 控制器更改为使用 AutoMapper 来处理对象映射。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Tasks<span class="token punctuation">;</span>
<span class="token keyword">using</span> AutoMapper<span class="token punctuation">;</span>
<span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Mvc<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Services<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Resources<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Controllers
<span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token class-name">Route</span><span class="token punctuation">(</span><span class="token string">&quot;/api/[controller]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CategoriesController</span> <span class="token punctuation">:</span> <span class="token class-name">Controller</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">ICategoryService</span> _categoryService<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IMapper</span> _mapper<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">CategoriesController</span><span class="token punctuation">(</span><span class="token class-name">ICategoryService</span> categoryService<span class="token punctuation">,</span> <span class="token class-name">IMapper</span> mapper<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            _categoryService <span class="token operator">=</span> categoryService<span class="token punctuation">;</span>
            _mapper <span class="token operator">=</span> mapper<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token punctuation">[</span><span class="token class-name">HttpGet</span><span class="token punctuation">]</span>
        <span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>CategoryResource<span class="token operator">&gt;&gt;</span> <span class="token function">GetAllAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">var</span> categories <span class="token operator">=</span> <span class="token keyword">await</span> _categoryService<span class="token punctuation">.</span><span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> resources <span class="token operator">=</span> _mapper<span class="token punctuation">.</span>Map<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;</span><span class="token punctuation">,</span> IEnumerable<span class="token operator">&lt;</span>CategoryResource<span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span>categories<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token keyword">return</span> resources<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我修改了构造函数去接收实现了 <code>IMapper</code> 接口的对象。你可以使用接口中的方法去调用 Automapper 映射方法。</p> <p>我还更改了 <code>GetAllAsync</code> 方法，将类别枚举映射为使用map方法的资源枚举。此方法接收要映射的类或集合的实例，并通过<a href="https://www.geeksforgeeks.org/c-generics-introduction/" target="_blank" rel="noopener noreferrer">泛型类型定义<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>将其定义为必须映射的类或集合的类型。</p> <p>注意，我们可以很容易地更改实现，而不必修改服务类或存储库，只需向构造函数注入一个新的依赖项(<code>IMapper</code>)即可。</p> <p>依赖项注入使应用程序易于维护和更改，因为不必破坏所有代码实现来添加或删除特性。</p> <p>你可能意识到不仅控制器类，而且所有接收依赖的类(包括依赖本身)都被自动解析为根据绑定配置接收正确的类。</p> <p>依赖注入很神奇，不是吗?</p> <p>现在，再次使用 dotnet run 命令启动API，并转到http://localhost:5000/api/categories查看新的JSON响应。</p> <p><img src="/images/netcore/restful-api-3.png" alt="返回数据"></p> <p>我们已经有了 GET 端点。现在，让我们创建一个新的端点来发布(创建)类别。</p> <h2 id="步骤9-创建新的分类"><a href="#步骤9-创建新的分类" class="header-anchor">#</a> 步骤9 - 创建新的分类</h2> <p>当处理资源的创建, 我们必须要考虑很多事情, 比如:</p> <ul><li>数据有效性和完整性;</li> <li>创建资源的权限;</li> <li>错误处理;</li> <li>日志。</li></ul> <p>我不会在本篇教程中告诉你授权和验证的详细情况, 但是你可以阅读<a href="https://medium.com/@evandro.ggomes/json-web-token-authentication-with-asp-net-core-2-0-b074b0cfc870" target="_blank" rel="noopener noreferrer">我的 JSON web令牌身份验证教程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>时，你可以看到如何轻松实现这些功能。</p> <p>还有一个非常流行的框架叫做 <strong>ASP.NET Identity</strong>，它提供有关安全性和用户注册的内置解决方案，可以在应用程序中使用它。它提供与EF Core一起工作的方式，比如一个你可以使用的内建的 <code>IdentityDbContext</code>。你可以在<a href="https://docs.microsoft.com/en-us/aspnet/identity/overview/getting-started/introduction-to-aspnet-identity" target="_blank" rel="noopener noreferrer">这里了解更多<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>让我们编写一个 <strong>HTTP POST</strong> 端点，它将涵盖其他场景(日志记录除外，可以根据不同的范围和工具进行更改)。</p> <p>在创建这个新端点之前, 我们需要一个新的资源。这个资源将会映射客户端应用发送到这个端点(在本例中, 是类别名称)的数据到我们英语中的某个类。</p> <p>因为我们正在创建一个新类别，所以还没有ID，这意味着我们需要一个资源来表示只包含其名称的类别。</p> <p>在 <code>Resources</code> 文件夹, 添加一个 <code>SaveCategoryResource</code> 新类:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> System<span class="token punctuation">.</span>ComponentModel<span class="token punctuation">.</span>DataAnnotations<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Resources
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaveCategoryResource</span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">[</span><span class="token class-name">Required</span><span class="token punctuation">]</span>
        <span class="token punctuation">[</span><span class="token class-name">MaxLength</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">public</span> <span class="token keyword">string</span> Name <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意 <code>Name</code> 属性上的 <code>Required</code>和<code>MaxLength</code>这个两个attributes(特性)。这些特性叫做<a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations?view=netframework-4.7.2" target="_blank" rel="noopener noreferrer">数据注释<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。ASP.NET Core 管道中使用这些元数据去验证请求与响应的数据。正如名称所暗示的，类别名称是必需的，并且最大长度为30个字符。</p> <p>现在，让我们定义新API端点的具体化。将以下代码添加到 categories 控制器:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token class-name">HttpPost</span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>IActionResult<span class="token operator">&gt;</span> <span class="token function">PostAsync</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">FromBody</span><span class="token punctuation">]</span> <span class="token class-name">SaveCategoryResource</span> resource<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们告诉框架这是一个使用 <code>HttpPost</code> 特性表示的 HTTP POST 端点。</p> <p>注意这个方法的相应类型, <code>Task&lt;IActionResult&gt;</code> 。控制器类中出现的方法称为 <strong>actions</strong>，它们具有此签名，因为我们可以在应用程序执行操作后返回多个可能的结果。</p> <p>在这种情况下, 如果类别的名称是无效的,如果出现问题,我们必须返回一个<strong>400的代码</strong>(<strong>坏的请求</strong>)响应,通常包含一个错误消息,客户机应用程序可以使用它来对待这个问题,或者我们可以在一起正常的情况下返回一个<strong>200响应</strong>(<strong>成功</strong>)的数据。</p> <p>作为响应, 我们可以使用很多操作响应类型, 但通常情况下, 我们可以使用这个接口和 ASP.NET Core 将为此使用一个默认类。</p> <p><code>FromBody</code> 特性告诉 ASP.NET Core 将请求体数据解析到我们的新资源类。这意味着，当包含类别名称的 JSON 被发送到我们的应用程序时，框架将自动将其解析为我们的新类。</p> <p>现在, 让我们实现我们的路由逻辑。我们必须按照一点的步骤才能成功创建一个新的类别:</p> <ul><li>首先, 我们必须验证传入的请求。如果请求无效，则必须返回包含错误消息的错误请求响应;</li> <li>然后, 如果请求有效, 我们必须使用 AutoMapper 映射我们的新资源到我们的类别模型类中;</li> <li>我们现在需要调用我们的服务, 告诉它保存我们的新类别。如果保存逻辑执行没有问题, 它应该返回一个包含我们新类别数据的响应。如果没有，它应该给我们一个进程失败的指示，以及一个潜在的错误消息;</li> <li>最后, 如果发生错误, 我们返回一个错误的请求。如果没有, 我们将新的类别模型映射到一个类别资源，并向客户端返回一个包含新类别数据的成功响应。</li></ul> <p>它看起来很复杂，但是使用我们为 API 构造的服务体系结构来实现这个逻辑确实很容易。</p> <p>让我们从验证传入的请求开始。</p> <h2 id="步骤10-使用模型状态验证请求主体"><a href="#步骤10-使用模型状态验证请求主体" class="header-anchor">#</a> 步骤10 - 使用模型状态验证请求主体</h2> <p>ASP.NET Core 的控制器有一个叫做 <code>ModelState</code> 的属性。此属性在请求执行期间填充，然后执行我们的操作。它是 <code>ModelStateDictionary</code> 的一个实例, 包含诸如请求是否有效和潜在验证错误等信息的类。</p> <p>修改端点的代码如下:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token class-name">HttpPost</span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>IActionResult<span class="token operator">&gt;</span> <span class="token function">PostAsync</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">FromBody</span><span class="token punctuation">]</span> <span class="token class-name">SaveCategoryResource</span> resource<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ModelState<span class="token punctuation">.</span>IsValid<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">BadRequest</span><span class="token punctuation">(</span>ModelState<span class="token punctuation">.</span><span class="token function">GetErrorMessages</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码检查模型状态(在本例中，是在请求体中发送的数据)是否无效，并检查我们的数据注释。如果不是，则API返回一个坏定请求(400状态码)和注释元数据提供的默认错误消息。</p> <p><code>ModelState.GetErrorMessages()</code> 方法还未实现。它是一个 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods" target="_blank" rel="noopener noreferrer">扩展方法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> (扩展现有类或接口的功能的方法), 我将实现它来将验证错误转换为简单的字符串以返回给客户端。</p> <p>在我们的 API 的根目录中添加一个新的文件夹 <code>Extensions</code>，然后添加一个新的类 <code>ModelStateExtensions</code>。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Linq<span class="token punctuation">;</span>
<span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Mvc<span class="token punctuation">.</span>ModelBinding<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Extensions
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ModelStateExtensions</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">&gt;</span> <span class="token function">GetErrorMessages</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token class-name">ModelStateDictionary</span> dictionary<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> dictionary<span class="token punctuation">.</span><span class="token function">SelectMany</span><span class="token punctuation">(</span>m <span class="token operator">=&gt;</span> m<span class="token punctuation">.</span>Value<span class="token punctuation">.</span>Errors<span class="token punctuation">)</span>
                             <span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>m <span class="token operator">=&gt;</span> m<span class="token punctuation">.</span>ErrorMessage<span class="token punctuation">)</span>
                             <span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所有的扩展方法必须是静态的, 以及声明它们的类。这意味着它们不处理特定的实例数据，并且它们只在应用程序启动时加载一次。</p> <p>参数声明前面的 <code>this</code> 关键字是告诉c#编译器把它当作一个扩展方法。目的是为了能让我们像调用这个类的普通方法一样调用它，因为我们在需要使用扩展的地方包含了相应的 <code>using</code> 指令。</p> <p>这个扩展使用了<a href="https://www.tutorialsteacher.com/linq/what-is-linq" target="_blank" rel="noopener noreferrer">LINQ查询<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这是 .NET 的一个非常有用的特性，允许我们使用链式表达式来查询和转换数据。这里的表达式将验证错误方法转换为包含错误消息的字符串列表。</p> <p>在执行下一步之前, 导入名称空间 <code>Supermarket.API.Extensions</code>到categories控制器中。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Extensions<span class="token punctuation">;</span>
</code></pre></div><p>让我们通过将新资源映射到类别模型类来继续实现端点逻辑。</p> <h2 id="步骤11-映射新的资源"><a href="#步骤11-映射新的资源" class="header-anchor">#</a> 步骤11 - 映射新的资源</h2> <p>我们已经定义了一个映射配置文件来将模型转换为资源。现在我们需要一个新的配置文件来做相反的事情。</p> <p>在 <code>Mapping</code> 中创建一个新的类 <code>ResourceToModelProfile</code> :</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> AutoMapper<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Resources<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Mapping
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResourceToModelProfile</span> <span class="token punctuation">:</span> <span class="token class-name">Profile</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token function">ResourceToModelProfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token generic-method"><span class="token function">CreateMap</span><span class="token punctuation">&lt;</span><span class="token class-name">SaveCategoryResource</span><span class="token punctuation">,</span> <span class="token class-name">Category</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里没有什么新的改动。多亏了依赖注入的，AutoMapper将在应用程序启动时自动注册这个配置文件，我们不需要更改任何其他地方来使用它。</p> <p>现在我们可以把我们的新资源映射到相应的模型类:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token class-name">HttpPost</span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>IActionResult<span class="token operator">&gt;</span> <span class="token function">PostAsync</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">FromBody</span><span class="token punctuation">]</span> <span class="token class-name">SaveCategoryResource</span> resource<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ModelState<span class="token punctuation">.</span>IsValid<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">BadRequest</span><span class="token punctuation">(</span>ModelState<span class="token punctuation">.</span><span class="token function">GetErrorMessages</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">var</span> category <span class="token operator">=</span> _mapper<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">SaveCategoryResource</span><span class="token punctuation">,</span> <span class="token class-name">Category</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="步骤12-使用请求-响应模式来处理保存逻辑"><a href="#步骤12-使用请求-响应模式来处理保存逻辑" class="header-anchor">#</a> 步骤12 - 使用请求-响应模式来处理保存逻辑</h2> <p>现在我们必须实现最有趣的逻辑:保存一个新类别。我们希望我们的服务能做到这一点。</p> <p>保存逻辑可能会因为连接到数据库时出现的问题而失败，或者可能因为任何内部业务规则都会使我们的数据无效。</p> <p>如果出现错误，我们不能简单地抛出一个错误，因为它可能会停止API，而客户端应用程序不知道如何处理这个问题。此外，我们可能会有一些日志机制来记录错误。</p> <p>保存方法的约定，它意味着方法和响应类型的签名，需要指出我们是否正确地执行了流程。如果过程顺利，我们将收到类别数据。如果没有，我们至少必须接收一条错误消息，说明进程失败的原因。</p> <p>我们可以使用请求-响应模式来实现这个功能。此企业级设计模式将我们的请求和响应参数封装到类中，作为一种封装信息的方式，我们的服务将使用这些信息来处理某些任务，并将信息返回给使用服务的类。</p> <p>这种模式给我们带来了一些好处，比如:</p> <ul><li>如果我们需要更改服务来接收更多参数，我们不必破坏它的签名;</li> <li>我们可以为我们的请求或响应定义一个标准契约;</li> <li>我们可以在不停止应用程序进程的情况下处理业务逻辑和潜在的故障，并且我们不需要使用大量的try-catch块。</li></ul> <p>让我们为处理数据更改的服务方法创建一个标准的响应类型。对于这种类型的每个请求，我们都想知道该请求执行时是否没有问题。如果失败，我们希望向客户端返回一条错误消息。</p> <p>在 <code>Domain</code> 文件夹中的  <code>Services</code> , 创建一个 <code>Communication</code> 的新文件夹。新建一个 <code>BaseResponse</code> 的新类。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Services<span class="token punctuation">.</span>Communication
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">BaseResponse</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">bool</span> Success <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">protected</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">string</span> Message <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">protected</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token function">BaseResponse</span><span class="token punctuation">(</span><span class="token keyword">bool</span> success<span class="token punctuation">,</span> <span class="token keyword">string</span> message<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            Success <span class="token operator">=</span> success<span class="token punctuation">;</span>
            Message <span class="token operator">=</span> message<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是一个抽象类, 我们的响应类型会继承它。</p> <p>该抽象定义了一个 <code>Success</code> 属性(它将告诉请求是否成功完成)和一个 <code>Message</code> 属性(如果某些操作失败，它将带有错误消息)。</p> <p>注意，这些属性是必需的，只有继承的类才能设置这些数据，因为子类必须通过构造函数传递这些信息。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>为所有的响应定义一个基类并不是一个好的设计, 因为<a href="https://en.wikipedia.org/wiki/Fragile_base_class" target="_blank" rel="noopener noreferrer">基类会耦合代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>并阻止你轻易地修改它。最好使用<a href="https://medium.com/humans-create-software/composition-over-inheritance-cb6f88070205" target="_blank" rel="noopener noreferrer">组合而不是继承<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>对于这个 API 的范围来说，使用基类并不是什么问题，因为我们的服务不会增长太多。如果你意识到服务或应用程序将频繁增长和更改，请避免使用基类。</p></div> <p>现在, 在同一个目录, 添加一个 <code>SaveCategoryResponse</code> 新类:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Services<span class="token punctuation">.</span>Communication
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaveCategoryResponse</span> <span class="token punctuation">:</span> <span class="token class-name">BaseResponse</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token class-name">Category</span> Category <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

        <span class="token keyword">private</span> <span class="token function">SaveCategoryResponse</span><span class="token punctuation">(</span><span class="token keyword">bool</span> success<span class="token punctuation">,</span> <span class="token keyword">string</span> message<span class="token punctuation">,</span> <span class="token class-name">Category</span> category<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>success<span class="token punctuation">,</span> message<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            Category <span class="token operator">=</span> category<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/// &lt;summary&gt;</span>
        <span class="token comment">/// Creates a success response.</span>
        <span class="token comment">/// &lt;/summary&gt;</span>
        <span class="token comment">/// &lt;param name=&quot;category&quot;&gt;Saved category.&lt;/param&gt;</span>
        <span class="token comment">/// &lt;returns&gt;Response.&lt;/returns&gt;</span>
        <span class="token keyword">public</span> <span class="token function">SaveCategoryResponse</span><span class="token punctuation">(</span><span class="token class-name">Category</span> category<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">,</span> <span class="token keyword">string</span><span class="token punctuation">.</span>Empty<span class="token punctuation">,</span> category<span class="token punctuation">)</span>
        <span class="token punctuation">{</span> <span class="token punctuation">}</span>

        <span class="token comment">/// &lt;summary&gt;</span>
        <span class="token comment">/// Creates am error response.</span>
        <span class="token comment">/// &lt;/summary&gt;</span>
        <span class="token comment">/// &lt;param name=&quot;message&quot;&gt;Error message.&lt;/param&gt;</span>
        <span class="token comment">/// &lt;returns&gt;Response.&lt;/returns&gt;</span>
        <span class="token keyword">public</span> <span class="token function">SaveCategoryResponse</span><span class="token punctuation">(</span><span class="token keyword">string</span> message<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token keyword">false</span><span class="token punctuation">,</span> message<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>响应类型同样设置为 <code>Category</code> 属性, 如果请求成功完成，该属性将包含我们的 Category 数据。</p> <p>注意，我为这个类定义了三个不同的构造函数:</p> <ul><li><p>私有的，它将把成功和消息参数传递给基类，并设置<code>Category</code>属性;</p></li> <li><p>仅将类别属性作为参数的构造函数。它将创建一个成功的响应，调用私有构造函数来设置相应的属性;</p></li> <li><p>第三个构造函数只指定消息。用于创建失败响应。</p></li></ul> <p>因为 C# 支持重载构造函数, 我们简化了响应的创建，不必定义不同的方法来处理它，只是使用了不同的构造函数。</p> <p>现在，我们可以更改服务接口来添加新的存储方法。</p> <p>将 <code>ICategoryService</code> 修改成如下:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Tasks<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Models<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Services<span class="token punctuation">.</span>Communication<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Services
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ICategoryService</span>
    <span class="token punctuation">{</span>
         Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;&gt;</span> <span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         Task<span class="token operator">&lt;</span>SaveCategoryResponse<span class="token operator">&gt;</span> <span class="token function">SaveAsync</span><span class="token punctuation">(</span><span class="token class-name">Category</span> category<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们将简单地将一个类别传递给这个方法，它将处理保存模型数据所需的所有逻辑，编排存储库和其他必要的服务。</p> <p>注意，这里我没有创建特定的请求类，因为我们不需要任何其他参数来执行此任务。在计算机编程中有一个概念叫做 <a href="https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle" target="_blank" rel="noopener noreferrer">KISS<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> —— <strong>简单，愚蠢</strong>。基本上，它说你应该让你的应用程序尽可能的简单。</p> <p>在设计应用程序时请记住这一点: <strong>只应用解决问题所需的内容。不要过度设计你的应用程序。</strong></p> <p>现在我们可以完成我们的端点逻辑:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token class-name">HttpPost</span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>IActionResult<span class="token operator">&gt;</span> <span class="token function">PostAsync</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">FromBody</span><span class="token punctuation">]</span> <span class="token class-name">SaveCategoryResource</span> resource<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ModelState<span class="token punctuation">.</span>IsValid<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">BadRequest</span><span class="token punctuation">(</span>ModelState<span class="token punctuation">.</span><span class="token function">GetErrorMessages</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">var</span> category <span class="token operator">=</span> _mapper<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">SaveCategoryResource</span><span class="token punctuation">,</span> <span class="token class-name">Category</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">await</span> _categoryService<span class="token punctuation">.</span><span class="token function">SaveAsync</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span>Success<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">BadRequest</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>Message<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">var</span> categoryResource <span class="token operator">=</span> _mapper<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Category</span><span class="token punctuation">,</span> <span class="token class-name">CategoryResource</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>Category<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">Ok</span><span class="token punctuation">(</span>categoryResource<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在验证了请求的数据映射到我们的模型资源后, 我们将其传递给我们的服务来保存数据。</p> <p>如果发生错误, API 返回一个错误响应。如果没有, API 映射一个新的类别(包含了新的 <code>Id</code>) 到我们之前创建的<code>CategoryResource</code> 并将其发送给客户端。</p> <p>现在, 让我们实现服务的真正逻辑。</p> <h2 id="步骤13-数据库逻辑和工作模式单元"><a href="#步骤13-数据库逻辑和工作模式单元" class="header-anchor">#</a> 步骤13 - 数据库逻辑和工作模式单元</h2> <p>因为我们要将数据持久化到数据库中，所以我们需要在存储库中添加一个新方法。</p> <p>添加一个新的<code>AddAsync</code>方法到<code>ICategoryRepository</code>接口:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ICategoryRepository</span>
<span class="token punctuation">{</span>
	 Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;&gt;</span> <span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token class-name">Task</span> <span class="token function">AddAsync</span><span class="token punctuation">(</span><span class="token class-name">Category</span> category<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在, 让我们在实际的repository类中实现这个方法:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CategoryRepository</span> <span class="token punctuation">:</span> <span class="token class-name">BaseRepository</span><span class="token punctuation">,</span> ICategoryRepository
<span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token function">CategoryRepository</span><span class="token punctuation">(</span><span class="token class-name">AppDbContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span>
	<span class="token punctuation">{</span> <span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;&gt;</span> <span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token keyword">await</span> _context<span class="token punctuation">.</span>Categories<span class="token punctuation">.</span><span class="token function">ToListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token class-name">Task</span> <span class="token function">AddAsync</span><span class="token punctuation">(</span><span class="token class-name">Category</span> category<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">await</span> _context<span class="token punctuation">.</span>Categories<span class="token punctuation">.</span><span class="token function">AddAsync</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里我们只是添加了一个新的类别到我们的集合。</p> <p>当我们将一个类添加到<code>DBSet&lt;&gt;</code>时，EF Core开始跟踪发生在我们的模型上的所有变化，并在当前状态下使用这些数据来生成查询将插入、更新或删除模型的。</p> <p>当前的实现只是简单地将模型添加到我们的集合中，但是<strong>我们的数据仍然不会被保存</strong>。</p> <p>有一个名为<code>SaveChanges</code>的方法出现在上下文类中，我们必须调用它才能真正执行到数据库中的查询语句。我没有在这里调用它，因为<a href="https://programmingwithmosh.com/entity-framework/common-mistakes-with-the-repository-pattern/" target="_blank" rel="noopener noreferrer">存储库不应该持久化数据<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，<strong>它只是对象在内存中的集合。</strong></p> <p>即使是在经验丰富的 .NET 开发人员之间，这个主题也很有争议，但是让我来解释一下为什么不应该在存储库类中调用<code>SaveChanges</code>。</p> <p>我们可以把存储库想象成 .NET 框架中的任何其他集合。当我们在 .NET (以及任一其它的编程语言, 如 Javascript和Java)中处理一个集合, 你通常可以:</p> <ul><li>添加一个新元素(就像往集合、数组、字典中添加元素);</li> <li>查找和筛选元素;</li> <li>从集合中移除一个元素;</li> <li>替换一个元素, 或者更新它。</li></ul> <p>想象一下现实世界中的集合。想象一下，你正在写一张购物清单，要在超市买东西(多么巧啊，不是吗?)</p> <p>在集合中, 你添加了所有需要购买的水果。你可以把水果添加到这个列表中，如果你不买的话就把一个水果移除，或者你可以替换一个水果的名字。但是你不能将水果<strong>保存</strong>到列表中。用平实的英语说这样的事没有意义。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>在用面向对象的编程语言设计类和接口时，尝试使用自然语言来检查你所做的是否正确。</p> <p>例如，说一个人实现了一个person接口是有意义的，但是一个人实现一个account是没有意义的。</p></div> <p>如果你想“保存”水果列表(在这种情况下，是购买所有的水果)，你需要付费，超市会处理库存数据，以检查他们是否需要从供应商那里购买更多的水果。</p> <p>在编程时可以应用相同的逻辑。存储库不应该保存、更新或删除数据。相反，它们应该将其委托给另一个类来处理这个逻辑。</p> <p>直接将数据保存到存储库时还存在另一个问题: <strong>不能使用事务</strong>。</p> <p>假设我们的应用程序有一个日志记录机制，该机制存储一些用户名，并在每次对API数据进行更改时执行操作。</p> <p>现在，假设由于某种原因，你调用了一个更新用户名的服务(这不是常见的场景，但是让我们考虑一下)。</p> <p>你同意要更改虚构用户表中的用户名，首先必须更新所有日志，以正确地告知谁执行了该操作，对吗?</p> <p>现在，假设我们为不同存储库中的用户和日志实现了更新方法，它们都调用了<code>SaveChanges</code>。如果其中一个方法在更新过程中失败了，会发生什么情况?你将以数据不一致而告终。</p> <p>我们应该只在所有更改完成后才将更改保存到数据库中。为了实现这个功能,  我们必须使用 <a href="https://en.wikipedia.org/wiki/Database_transaction" target="_blank" rel="noopener noreferrer">事物<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, 这基本上是大多数数据库实现的功能，只有在复杂的操作完成后才保存数据。</p> <p><em>“好吧，如果我们不能在这里保存东西，我们应该在哪里保存呢?”</em></p> <p>处理此问题的常见模式是 <a href="https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application" target="_blank" rel="noopener noreferrer">工作单元模式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。此模式由一个类组成，该类将我们的<code>AppDbContext</code>实例作为依赖项接收，并公开启动、完成或中止事务的方法。</p> <p>我们将使用一个工作单元的简单实现来处理这里的问题。</p> <p>在<code>Domain</code>层的<code>Repositories</code>文件夹中添加一个名为<code>IUnitOfWork</code>的新接口:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Tasks<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Repositories
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IUnitOfWork</span>
    <span class="token punctuation">{</span>
         <span class="token class-name">Task</span> <span class="token function">CompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如你所见，它只公开一个异步完成数据管理操作的方法。</p> <p>现在让我们添加真正的实现。</p> <p>在<code>Persistence</code>层的<code>RepositoriesRepositories</code>文件夹中添加一个名为<code>UnitOfWork</code>的新类:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">using</span> System<span class="token punctuation">.</span>Threading<span class="token punctuation">.</span>Tasks<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Domain<span class="token punctuation">.</span>Repositories<span class="token punctuation">;</span>
<span class="token keyword">using</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Persistence<span class="token punctuation">.</span>Contexts<span class="token punctuation">;</span>

<span class="token keyword">namespace</span> Supermarket<span class="token punctuation">.</span>API<span class="token punctuation">.</span>Persistence<span class="token punctuation">.</span>Repositories
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnitOfWork</span> <span class="token punctuation">:</span> <span class="token class-name">IUnitOfWork</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">AppDbContext</span> _context<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token function">UnitOfWork</span><span class="token punctuation">(</span><span class="token class-name">AppDbContext</span> context<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            _context <span class="token operator">=</span> context<span class="token punctuation">;</span>     
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token class-name">Task</span> <span class="token function">CompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">await</span> _context<span class="token punctuation">.</span><span class="token function">SaveChangesAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是一个简单、干净的实现，它只会在你使用存储库完成修改之后将所有更改保存到数据库中。</p> <p>如果你研究工作单元模式的实现，你将发现更复杂的实现回滚操作的实现。</p> <p>由于<strong>EF Core已经在幕后实现了存储库模式和工作单元</strong>，所以我们不需要关心回滚方法。</p> <p>”——什么?那么，为什么我们必须创建所有这些接口和类吗?”</p> <p>将持久性逻辑与业务规则分离在代码可重用性和维护方面提供了许多优势。如果我们直接使用EF Core，我们最终会得到更复杂的类，这些类不太容易修改。</p> <p>假设将来你决定将 ORM 框架更改为不同的框架，例如<a href="https://www.c-sharpcorner.com/article/crud-operation-in-asp-net-core-2-0-using-dapper-orm/" target="_blank" rel="noopener noreferrer">Dapper<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，或者由于性能原因必须实现普通SQL查询。如果将查询逻辑与服务耦合，则很难更改逻辑，因为在很多类中都必须这样做。</p> <p>使用repository(仓储)模式，你可以简单地实现一个新的repository类，并使用依赖项注入对其进行绑定。</p> <p>所以，基本上，如果你在你的服务中直接使用EF Core，你必须改变一些东西，你会得到:</p> <p>如上文所述，EF Core在背后实现了工作单元和仓储模式。我们可以将**DbSet&lt;&gt;**属性视为存储库。另外，<strong>SaveChanges</strong>仅在所有数据库操作成功的情况下保存数据。</p> <p>现在你已经知道了什么是工作单元，以及为什么要将它与存储库一起使用，接下来让我们实现真正的服务逻辑。</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CategoryService</span> <span class="token punctuation">:</span> <span class="token class-name">ICategoryService</span>
<span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">ICategoryRepository</span> _categoryRepository<span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IUnitOfWork</span> _unitOfWork<span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token function">CategoryService</span><span class="token punctuation">(</span><span class="token class-name">ICategoryRepository</span> categoryRepository<span class="token punctuation">,</span> <span class="token class-name">IUnitOfWork</span> unitOfWork<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		_categoryRepository <span class="token operator">=</span> categoryRepository<span class="token punctuation">;</span>
		_unitOfWork <span class="token operator">=</span> unitOfWork<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;&gt;</span> <span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token keyword">await</span> _categoryRepository<span class="token punctuation">.</span><span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>SaveCategoryResponse<span class="token operator">&gt;</span> <span class="token function">SaveAsync</span><span class="token punctuation">(</span><span class="token class-name">Category</span> category<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">try</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">await</span> _categoryRepository<span class="token punctuation">.</span><span class="token function">AddAsync</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">await</span> _unitOfWork<span class="token punctuation">.</span><span class="token function">CompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			
			<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SaveCategoryResponse</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token comment">// Do some logging stuff</span>
			<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SaveCategoryResponse</span><span class="token punctuation">(</span>$<span class="token string">&quot;An error occurred when saving the category: {ex.Message}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于我们的解耦架构，我们可以简单地传递一个<strong>UnitOfWork</strong>实例作为这个类的依赖项。</p> <p>我们的业务逻辑非常简单。</p> <p>首先，我们尝试将新类别添加到数据库中，然后API尝试保存它，将所有内容包装在try-catch块中。</p> <p>如果发生故障，API将调用某个虚构的日志服务并返回一个表示故障的响应。</p> <p>如果流程结束时没有问题，应用程序将返回一个成功响应，发送类别数据。简单,是吧?</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>在实际应用程序中，不应该将所有内容都封装在一个通用try-catch块中，而是应该分别处理所有可能的错误。</p> <p>简单地添加try-catch块无法覆盖大多数可能的失败场景。确保正确的实现错误处理。</p></div> <p>测试我们的API之前的最后一步是将工作单元接口绑定到它各自的类。</p> <p>将这行代码添加到<code>Startup</code>类的<code>ConfigureServices</code>方法中:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code>services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddScoped</span><span class="token punctuation">&lt;</span><span class="token class-name">IUnitOfWork</span><span class="token punctuation">,</span> <span class="token class-name">UnitOfWork</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>现在, 让我们测试它!</p> <h2 id="步骤14-使用postman测试我们的post端点"><a href="#步骤14-使用postman测试我们的post端点" class="header-anchor">#</a> 步骤14 - 使用Postman测试我们的POST端点</h2> <p>再次使用<code>dotnet run</code>启动我们的应用程序。</p> <p>我们不能使用浏览器来测试<strong>POST</strong>端点。让我们使用<strong>Postman</strong>来测试我们的端点。它是一个非常好的测试RESTful APIs的工具。</p> <p>打开Postman并关闭介绍消息。你会看到这样的屏幕:</p> <p><img src="/images/netcore/restful-api-4.png" alt="postman"></p> <p>将默认选中的<code>GET</code>更改为<code>POST</code>的选择框。</p> <p>在<code>Enter request URL</code>字段中键入API地址。</p> <p>我们必须提供发送给API的请求体数据。单击<code>Body</code>菜单项，然后将其下面显示的选项更改为<code>raw</code>。</p> <p>Postman将在右边显示一个<code>Text</code>选项。将其更改为<code>JSON (application/ JSON)</code>，并粘贴以下<strong>JSON</strong>数据:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="/images/netcore/restful-api-5.png" alt="postman"></p> <p>如你所见, 我们将向新端点发送一个空名称字符串。</p> <p>单击<code>Send</code>按钮。你会收到这样的输出:</p> <p><img src="/images/netcore/restful-api-6.png" alt="postman"></p> <p>你还记得我们为端点创建的验证逻辑吗?这个输出就是它工作的证明!</p> <p>还要注意右侧显示的400状态码。BadRequest结果会自动将此状态代码添加到响应中。</p> <p>现在让我们将JSON数据更改为一个有效的数据，以查看新的响应:</p> <p><img src="/images/netcore/restful-api-7.png" alt="postman"></p> <p>API正确地创建了我们的新资源。</p> <p>到目前为止，我们的API可以列出和创建类别。你学了很多关于C#语言的东西，ASP.NET核心框架以及构造API的常用设计方法。</p> <p>让我们继续创建用于更新类别的端点的categories API。</p> <p>从现在开始，既然我已经向你们解释了大部分概念，我将加快解释的速度，把注意力放在新的主题上，以免浪费你们的时间。我们开始吧!</p> <h2 id="步骤15-更新类别"><a href="#步骤15-更新类别" class="header-anchor">#</a> 步骤15 - 更新类别</h2> <p>为了更新类别, 我们需要一个HTTP PUT端点。</p> <p>我们必须实现的逻辑与POST非常相似:</p> <ul><li>首先, 我们必须使用 <code>ModelState</code> 来验证传入的请求数据;</li> <li>如果请求是有效的，API应该使用AutoMapper将传入的资源映射到模型类;</li> <li>然后，我们需要调用我们的服务，告诉它更新类别，提供相应的类别<code>Id</code>和更新后的数据;</li> <li>如果数据库中没有具有给定<code>Id</code>的类别，则返回一个错误请求。我们可以使用<code>NotFound</code>结果，但这对于这个范围来说并不重要，因为我们向客户应用程序提供了一条错误消息;</li> <li>如果保存逻辑正确执行，服务必须返回一个包含更新的类别数据的响应。如果没有，它应该给我们一个过程失败的指示，并告诉我们原因;</li> <li>最后，如果出现错误，API将返回一个错误请求。如果没有，它将更新后的类别模型映射到类别资源，并向客户应用程序返回一个成功响应。</li></ul> <p>让我们将新的<code>PutAsync</code>方法添加到控制器类中:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token class-name">HttpPut</span><span class="token punctuation">(</span><span class="token string">&quot;{id}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>IActionResult<span class="token operator">&gt;</span> <span class="token function">PutAsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token class-name">FromBody</span><span class="token punctuation">]</span> <span class="token class-name">SaveCategoryResource</span> resource<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ModelState<span class="token punctuation">.</span>IsValid<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">BadRequest</span><span class="token punctuation">(</span>ModelState<span class="token punctuation">.</span><span class="token function">GetErrorMessages</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">var</span> category <span class="token operator">=</span> _mapper<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">SaveCategoryResource</span><span class="token punctuation">,</span> <span class="token class-name">Category</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">await</span> _categoryService<span class="token punctuation">.</span><span class="token function">UpdateAsync</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> category<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span>Success<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">BadRequest</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>Message<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">var</span> categoryResource <span class="token operator">=</span> _mapper<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Category</span><span class="token punctuation">,</span> <span class="token class-name">CategoryResource</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>Category<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">Ok</span><span class="token punctuation">(</span>categoryResource<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果你将它与<strong>POST</strong>逻辑进行比较，你会注意到这里只有一个区别:<code>HttPut</code>属性指定了给定路由应该接收的参数。</p> <p>我们将调用此端点，并指定类别<code>Id</code>作为最后一个URL片段，如<code>/api/categories/1</code>。ASP.NET核心管道将这个片段解析为同名的参数。</p> <p>现在我们必须在<code>ICategoryService</code>接口中定义<code>UpdateAsync</code>方法签名:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ICategoryService</span>
<span class="token punctuation">{</span>
	Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;&gt;</span> <span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Task<span class="token operator">&lt;</span>SaveCategoryResponse<span class="token operator">&gt;</span> <span class="token function">SaveAsync</span><span class="token punctuation">(</span><span class="token class-name">Category</span> category<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Task<span class="token operator">&lt;</span>SaveCategoryResponse<span class="token operator">&gt;</span> <span class="token function">UpdateAsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token class-name">Category</span> category<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在让我们转到真正的逻辑。</p> <h2 id="步骤16-更新逻辑"><a href="#步骤16-更新逻辑" class="header-anchor">#</a> 步骤16 - 更新逻辑</h2> <p>要更新类别，首先需要从数据库中返回当前数据(如果存在的话)。我们还需要将它更新到我们的<code>DBSet&lt;&gt;</code>。</p> <p>让我们向<code>ICategoryService</code>接口添加两个新方法:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ICategoryRepository</span>
<span class="token punctuation">{</span>
	Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;&gt;</span> <span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">Task</span> <span class="token function">AddAsync</span><span class="token punctuation">(</span><span class="token class-name">Category</span> category<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Task<span class="token operator">&lt;</span>Category<span class="token operator">&gt;</span> <span class="token function">FindByIdAsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token class-name">Category</span> category<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们已经定义了<code>FindByIdAsync</code>方法，它将异步地从数据库返回一个类别，并定义了<code>Update</code>方法。注意，<code>Update</code>方法不是异步的，因为EF Core API不需要异步方法来更新模型。</p> <p>现在让我们将真正的逻辑实现到<code>CategoryRepository</code>类中:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code>
<span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>Category<span class="token operator">&gt;</span> <span class="token function">FindByIdAsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token keyword">await</span> _context<span class="token punctuation">.</span>Categories<span class="token punctuation">.</span><span class="token function">FindAsync</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token class-name">Category</span> category<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	_context<span class="token punctuation">.</span>Categories<span class="token punctuation">.</span><span class="token function">Update</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后我们可以进行编码服务逻辑:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>SaveCategoryResponse<span class="token operator">&gt;</span> <span class="token function">UpdateAsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token class-name">Category</span> category<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">var</span> existingCategory <span class="token operator">=</span> <span class="token keyword">await</span> _categoryRepository<span class="token punctuation">.</span><span class="token function">FindByIdAsync</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>existingCategory <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SaveCategoryResponse</span><span class="token punctuation">(</span><span class="token string">&quot;Category not found.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	existingCategory<span class="token punctuation">.</span>Name <span class="token operator">=</span> category<span class="token punctuation">.</span>Name<span class="token punctuation">;</span>

	<span class="token keyword">try</span>
	<span class="token punctuation">{</span>
		_categoryRepository<span class="token punctuation">.</span><span class="token function">Update</span><span class="token punctuation">(</span>existingCategory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">await</span> _unitOfWork<span class="token punctuation">.</span><span class="token function">CompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SaveCategoryResponse</span><span class="token punctuation">(</span>existingCategory<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">// Do some logging stuff</span>
		<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SaveCategoryResponse</span><span class="token punctuation">(</span>$<span class="token string">&quot;An error occurred when updating the category: {ex.Message}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>API尝试从数据库获取类别。如果结果为 <code>null</code>，则返回一个响应，说明类别不存在。如果类别存在，我们需要设置它的新名称。</p> <p>然后，API尝试保存更改，就像创建新类别时一样。如果流程完成，服务将返回一个成功响应。如果不是，则执行日志逻辑，端点接收包含错误消息的响应。</p> <p>现在我们来测试一下。首先，让我们添加一个新的类别来拥有一个可用的有效<code>Id</code>。我们可以使用我们在数据库中添加的类别的标识符，但是我想这样做是为了向你展示我们的API将更新正确的资源。</p> <p>再次运行应用程序，使用Postman向数据库POST一个新类别:</p> <p><img src="/images/netcore/restful-api-8.png" alt="postman"></p> <p>有了有效的<code>Id</code>之后，将<code>POST</code>选项改为<code>PUT</code>到选择框中，并在URL的末尾添加Id值。将<code>name</code>属性更改为另一个名称，并发送请求检查结果:</p> <p><img src="/images/netcore/restful-api-9.png" alt="postman"></p> <p>你可以发送一个GET请求到API端点，以确保你正确地编辑了类别名:</p> <p><img src="/images/netcore/restful-api-10.png" alt="postman"></p> <p>对于类别，我们必须实现的最后一个操作是排除类别。让我们创建一个HTTP Delete端点。</p> <h2 id="步骤17-删除类别"><a href="#步骤17-删除类别" class="header-anchor">#</a> 步骤17 - 删除类别</h2> <p>删除类别的逻辑非常容易实现，因为我们需要的大多数方法都是以前构建的。</p> <p>以下是我们路由工作的必要步骤:</p> <ul><li><p>API需要调用我们的服务，告诉它删除我们的类别，并提供相应的<code>Id</code>;</p></li> <li><p>如果数据库中没有具有给定ID的类别，则服务应返回一条指示它的消息;</p></li> <li><p>如果执行删除逻辑没有问题，则服务应该返回一个包含已删除类别数据的响应。如果没有，它应该给我们一个进程失败的指示，以及一个潜在的错误消息;</p></li> <li><p>最后，如果出现错误，API将返回一个错误请求。如果没有，API将更新后的类别映射到资源，并向客户端返回一个成功响应。</p></li></ul> <p>让我们开始添加新的端点逻辑:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token class-name">HttpDelete</span><span class="token punctuation">(</span><span class="token string">&quot;{id}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>IActionResult<span class="token operator">&gt;</span> <span class="token function">DeleteAsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">await</span> _categoryService<span class="token punctuation">.</span><span class="token function">DeleteAsync</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span>Success<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">BadRequest</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>Message<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">var</span> categoryResource <span class="token operator">=</span> _mapper<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">Category</span><span class="token punctuation">,</span> <span class="token class-name">CategoryResource</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>Category<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">Ok</span><span class="token punctuation">(</span>categoryResource<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>HttpDelete</code>属性还定义了一个<code>id</code>模板。</p> <p>在将<code>DeleteAsync</code>签名添加到<code>ICategoryService</code>接口之前，我们需要进行一个小的重构。</p> <p>新的服务方法必须返回包含类别数据的响应，这与我们对<code>PostAsync</code>和<code>UpdateAsync</code>方法所做的相同。我们可以为此重用<code>SaveCategoryResponse</code>，但是在本例中我们不保存数据。</p> <p>为了避免创建具有相同形状的新类来交付这个需求，我们可以简单地将<code>SaveCategoryResponse</code>重命名为<code>CategoryResponse</code>。</p> <p>如果你使用的是Visual Studio Code，你可以打开<code>SaveCategoryResponse</code>类，将鼠标光标放在类名的上方，并使用选项<code>Change All Occurrences</code>来重命名类:</p> <p><img src="/images/netcore/restful-api-11.png" alt="postman"></p> <p>一定要重新命名文件名。</p> <p>让我们将<code>DeleteAsync</code>方法签名添加到<code>ICategoryService</code>接口:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ICategoryService</span>
<span class="token punctuation">{</span>
	Task<span class="token operator">&lt;</span>IEnumerable<span class="token operator">&lt;</span>Category<span class="token operator">&gt;&gt;</span> <span class="token function">ListAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Task<span class="token operator">&lt;</span>CategoryResponse<span class="token operator">&gt;</span> <span class="token function">SaveAsync</span><span class="token punctuation">(</span><span class="token class-name">Category</span> category<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Task<span class="token operator">&lt;</span>CategoryResponse<span class="token operator">&gt;</span> <span class="token function">UpdateAsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token class-name">Category</span> category<span class="token punctuation">)</span><span class="token punctuation">;</span>
	Task<span class="token operator">&lt;</span>CategoryResponse<span class="token operator">&gt;</span> <span class="token function">DeleteAsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在实现删除逻辑之前，我们需要在存储库中添加一个新方法。</p> <p>将<code>Remove</code>方法签名添加到<code>ICategoryRepository</code>接口:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">void</span> <span class="token function">Remove</span><span class="token punctuation">(</span><span class="token class-name">Category</span> category<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>现在在repository类中添加真正的实现:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Remove</span><span class="token punctuation">(</span><span class="token class-name">Category</span> category<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	_context<span class="token punctuation">.</span>Categories<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>EF Core需要将模型的实例传递给<code>Remove</code>方法来正确地理解我们要删除的模型，而不是简单地传递一个<code>Id</code>。</p> <p>最后，我们来实现<code>CategoryService</code>类的逻辑:</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">async</span> Task<span class="token operator">&lt;</span>CategoryResponse<span class="token operator">&gt;</span> <span class="token function">DeleteAsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">var</span> existingCategory <span class="token operator">=</span> <span class="token keyword">await</span> _categoryRepository<span class="token punctuation">.</span><span class="token function">FindByIdAsync</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>existingCategory <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CategoryResponse</span><span class="token punctuation">(</span><span class="token string">&quot;Category not found.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">try</span>
	<span class="token punctuation">{</span>
		_categoryRepository<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>existingCategory<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">await</span> _unitOfWork<span class="token punctuation">.</span><span class="token function">CompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CategoryResponse</span><span class="token punctuation">(</span>existingCategory<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">// Do some logging stuff</span>
		<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CategoryResponse</span><span class="token punctuation">(</span>$<span class="token string">&quot;An error occurred when deleting the category: {ex.Message}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这没什么新鲜的。该服务尝试通过ID查找类别，然后调用存储库来删除类别。最后，工作单元完成对数据库执行实际操作的事务。</p> <p><em>”-嘿，那每个类别的产品呢?难道你不需要先创建一个存储库并删除产品，以避免错误吗?”</em></p> <p>答案是<strong>否</strong>。由于<a href="https://docs.microsoft.com/en-us/ef/core/querying/tracking" target="_blank" rel="noopener noreferrer">EF Core 跟踪机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，当我们从数据库加载一个模型时，框架知道该模型具有哪些关系。如果我们删除它，EF Core知道它应该先递归地删除所有相关的模型。</p> <p>我们可以在将类映射到数据库表时禁用此功能，但这超出了本教程的范围。如果你想了解这个特性，请查看<a href="https://entityframeworkcore.com/saving-data-cascade-delete" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>现在是测试新端点的时候了。再次运行应用程序，并发送删除请求使用Postman如下:</p> <p><img src="/images/netcore/restful-api-12.png" alt="postman"></p> <p>我们可以通过发送一个GET请求来检查我们的API是否正确工作:</p> <p><img src="/images/netcore/restful-api-13.png" alt="postman"></p> <p>我们已经完成了categories API。现在该转向products API了。</p> <h2 id="步骤18-产品的api"><a href="#步骤18-产品的api" class="header-anchor">#</a> 步骤18 - 产品的API</h2> <p>到目前为止，你已经学习了如何使用ASP.NET Core实现所有基本的HTTP动词来处理CRUD操作。让我们进入实现产品API的下一层。</p> <p>我不会再详细说明所有HTTP动词，因为它是详尽的。对于本教程的最后一部分，我将只讨论GET请求，以向你展示如何在查询数据库中的数据时包含相关实体，以及如何使用为<code>EUnitOfMeasurement</code>枚举值定义的<code>Description</code>属性。</p> <p>在<code>Controllers</code>文件夹中添加一个名为<code>ProductsController</code>的新控制器。</p> <p>在编写任何代码之前，我们必须创建产品资源。</p> <p>让我刷新你的记忆，再次显示我们的资源应该是什么样子的:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
 <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
   <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
   <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Sugar&quot;</span><span class="token punctuation">,</span>
   <span class="token property">&quot;quantityInPackage&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
   <span class="token property">&quot;unitOfMeasurement&quot;</span><span class="token operator">:</span> <span class="token string">&quot;KG&quot;</span>
   <span class="token property">&quot;category&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
   <span class="token property">&quot;id&quot;</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
   <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Sugar&quot;</span>
   <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  … <span class="token comment">// Other products</span>
 <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们需要一个包含数据库中所有产品的JSON数组。</p> <p>JSON数据与产品模型有两个不同之处:</p> <ul><li>计量单位以较短的方式显示，只显示其缩写;</li> <li>我们输出类别数据，但不包括<code>CategoryId</code>属性。</li></ul> <p>为了表示度量单位，我们可以使用一个简单的字符串属性来代替enum类型(顺便说一下，JSON数据没有默认的enum类型，所以我们必须将其转换为另一种类型)。</p> <p>现在我们已经知道了如何塑造新资源，让我们来创建它。在<code>Resources</code>文件夹中添加一个新的类<code>ProductResource</code>:</p> <p>现在，我们必须配置模型类和新资源类之间的映射。</p> <p>映射配置将与用于其他映射的配置几乎相同，但是这里我们必须处理将 <code>EUnitOfMeasurement</code> 枚举转换为字符串。</p> <p>还记得在枚举类型上应用的<code>StringValue</code>属性吗? 现在，我将向你展示如何使用. net框架的一个强大特性:<a href="https://www.tutorialspoint.com/csharp/csharp_reflection.htm" target="_blank" rel="noopener noreferrer">反射API<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来提取这些信息。</p> <p>反射API是一组强大的资源，它允许我们提取和操作元数据。很多框架和库(包括ASP.NET Core自身利用这些资源在幕后处理许多事情。</p> <p>现在让我们看看它在实践中是如何工作的。在<code>Extensions</code>文件夹中添加一个名为<code>EnumExtensions</code>的新类。</p> <p>第一次看到代码时，你可能会感到害怕，但它并没有那么复杂。让我们分解一下代码定义来理解它是如何工作的。</p> <p>首先，我们定义了一个<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/" target="_blank" rel="noopener noreferrer">泛型方法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>(该方法可以接收不止一种类型的参数，在本例中，由<code>TEnum</code>声明表示)，该方法接收一个给定的enum作为参数。</p> <p>因为<code>enum</code>是C#中的一个保留关键字，所以我们在参数名前面添加了一个@，以使它成为一个有效的名称。</p> <p>此方法的第一个执行步骤是使用<code>GetType</code>方法获取参数的类型信息(类、接口、枚举或结构定义)。</p> <p>然后，该方法使用<code>GetField(@enum.ToString())</code>获取特定的枚举值(例如，kg)。</p> <p>下一行查找在枚举值上应用的所有<code>Description</code>属性，并将它们的数据存储到一个数组中(在某些情况下，我们可以为同一属性指定多个属性)。</p> <p>最后一行使用较短的语法检查枚举类型是否至少有一个description属性。如果有，则返回此属性提供的<code>Description</code>值。如果没有，则使用默认的强制转换将枚举作为字符串返回。</p> <p><code>?.</code>操作符(空条件操作符)在访问属性之前检查值是否为空。</p> <p>的<code>??</code>运算符(null-coalescing运算符)告诉应用程序，如果左边的值不为空，则返回左边的值，否则返回右边的值。</p> <p>现在我们有了一个提取描述的扩展方法，让我们来配置模型和资源之间的映射。多亏了AutoMapper，我们只需要多一行就可以做到这一点。</p> <p>打开<code>ModelToResourceProfile</code>类，并通过以下方式更改代码:</p> <p>这个语法告诉AutoMapper使用新的扩展方法将我们的<code>EUnitOfMeasurement</code>值转换成一个包含它的描述的字符串。简单,是吧?你可以<a href="http://docs.automapper.org/en/stable/Inline-Mapping.html" target="_blank" rel="noopener noreferrer">阅读官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>以了解完整的语法。</p> <p>注意，我们没有为category属性定义任何映射配置。因为我们之前为类别配置了映射，而且产品模型具有相同类型和名称的类别属性，AutoMapper隐式地知道应该使用相应的配置来映射它。</p> <p>现在让我们添加端点代码。更改<code>ProductsController</code>代码:</p> <p>基本上，为categories控制器定义了相同的结构。</p> <p>让我们进入服务部分。在<code>Domain</code>层的<code>Services</code>文件夹中添加一个新的<code>IProductService</code>接口:</p> <p>在真正实现新服务之前，你应该意识到我们需要一个存储库。</p> <p>在相应的文件夹中添加一个名为<code>IProductRepository</code>的新接口:</p> <p>现在让我们实现存储库。除了在查询数据时需要返回每个产品的相应类别数据之外，我们必须以几乎与实现类别存储库相同的方式实现它。</p> <p>默认情况下，当你查询数据时，EF Core 不会将相关实体包括到你的模型中，因为它可能非常慢(想象一个有10个相关实体的模型，所有的相关实体都有自己的关系)。</p> <p>为了包含类别数据，我们只需要多一行:</p> <p>注意<code>Include(p =&gt; p. category)</code>的调用。在查询数据时，我们可以链接此语法以包含尽可能多的实体。当执行select时，EF Core将把它转换成一个join。</p> <p>现在我们可以实现<code>ProductService</code>类，就像我们实现categories一样:</p> <p>让我们绑定新的依赖关系，改变<code>Startup</code>类:</p> <p>最后，在测试API之前，让我们更改AppDbContext类，在初始化应用程序时包含一些产品，这样我们可以看到结果:</p> <p>在初始化应用程序时，我添加了两个虚构的产品，将它们关联到我们创建的类别。</p> <p>考验时间!再次运行API，使用Postman向 <code>/api/products</code> 送GET请求:</p> <p><img src="/images/netcore/restful-api-14.png" alt="postman"></p> <p>就是它!恭喜你!</p> <p>现在你已经了解了如何使用ASP.NET Core构建一个解耦的RESTful API架构。你学习了.Net Core框架的许多内容，如何使用C#， EF Core和AutoMapper的基础知识，以及在设计应用程序时可以使用的许多有用的模式。</p> <p>你可以检查API的完整实现，包含产品的其他HTTP动词，检查Github仓库:</p> <p><a href="https://github.com/evgomes/supermarket-api" target="_blank" rel="noopener noreferrer"><strong>evgomes/supermarket-api</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://github.com/evgomes/supermarket-api" target="_blank" rel="noopener noreferrer">*Simple RESTful API built with ASP.NET Core 2.2 to show how to create RESTful services using a decoupled, maintainable…*github.com<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="结语"><a href="#结语" class="header-anchor">#</a> 结语</h2> <p>ASP.NET Core是创建web应用程序时使用的一个很好的框架。它提供了许多有用的api，你可以使用它们来构建干净的、可维护的应用程序。在创建专业应用程序时，可以考虑使用它。</p> <p>本文并没有涉及专业API的所有方面，但是你已经了解了所有的基础知识。你还学习了许多有用的模式来解决我们每天面对的模式。</p> <p>我希望你喜欢这篇文章，我希望它对你有用。感谢你的反馈，以了解我如何改进这一点。</p> <h4 id="引用"><a href="#引用" class="header-anchor">#</a> 引用</h4> <p><a href="https://docs.microsoft.com/en-us/dotnet/core/tutorials/" target="_blank" rel="noopener noreferrer">.NET Core Tutorials — Microsoft Docs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://docs.microsoft.com/en-us/aspnet/#pivot=core&amp;panel=core_tutorials" target="_blank" rel="noopener noreferrer">ASP.NET Core Documentation — Microsoft Docs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time"> 2020年 04月 16日 15:32:58</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/netcore/other/netcore-tips.html">DotNetCore 开发踩坑记录</a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.fa3e3824.js" defer></script><script src="/assets/js/2.230529bd.js" defer></script><script src="/assets/js/23.0815466b.js" defer></script>
  </body>
</html>
